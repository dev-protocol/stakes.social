schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

# current user lockup information.
#
#
# columns and relationships of "account_lockup"
#
type account_lockup {
  # account address
  account_address: String!

  # block number
  block_number: Int!

  # event id of lockup_lockedup
  locked_up_event_id: String!

  # property address
  property_address: String!

  # lockup value
  value: numeric!
}

# aggregated selection of "account_lockup"
type account_lockup_aggregate {
  aggregate: account_lockup_aggregate_fields
  nodes: [account_lockup!]!
}

# aggregate fields of "account_lockup"
type account_lockup_aggregate_fields {
  avg: account_lockup_avg_fields
  count(columns: [account_lockup_select_column!], distinct: Boolean): Int
  max: account_lockup_max_fields
  min: account_lockup_min_fields
  stddev: account_lockup_stddev_fields
  stddev_pop: account_lockup_stddev_pop_fields
  stddev_samp: account_lockup_stddev_samp_fields
  sum: account_lockup_sum_fields
  var_pop: account_lockup_var_pop_fields
  var_samp: account_lockup_var_samp_fields
  variance: account_lockup_variance_fields
}

# order by aggregate values of table "account_lockup"
input account_lockup_aggregate_order_by {
  avg: account_lockup_avg_order_by
  count: order_by
  max: account_lockup_max_order_by
  min: account_lockup_min_order_by
  stddev: account_lockup_stddev_order_by
  stddev_pop: account_lockup_stddev_pop_order_by
  stddev_samp: account_lockup_stddev_samp_order_by
  sum: account_lockup_sum_order_by
  var_pop: account_lockup_var_pop_order_by
  var_samp: account_lockup_var_samp_order_by
  variance: account_lockup_variance_order_by
}

# input type for inserting array relation for remote table "account_lockup"
input account_lockup_arr_rel_insert_input {
  data: [account_lockup_insert_input!]!
  on_conflict: account_lockup_on_conflict
}

# aggregate avg on columns
type account_lockup_avg_fields {
  block_number: Float
  value: Float
}

# order by avg() on columns of table "account_lockup"
input account_lockup_avg_order_by {
  block_number: order_by
  value: order_by
}

# Boolean expression to filter rows from the table "account_lockup". All fields are combined with a logical 'AND'.
input account_lockup_bool_exp {
  _and: [account_lockup_bool_exp]
  _not: account_lockup_bool_exp
  _or: [account_lockup_bool_exp]
  property_meta: property_meta_bool_exp
  account_address: String_comparison_exp
  block_number: Int_comparison_exp
  locked_up_event_id: String_comparison_exp
  property_address: String_comparison_exp
  value: numeric_comparison_exp
}

# unique or primary key constraints on table "account_lockup"
enum account_lockup_constraint {
  # unique or primary key constraint
  account_lockup_pkey
}

# input type for incrementing integer column in table "account_lockup"
input account_lockup_inc_input {
  block_number: Int
  value: numeric
}

# input type for inserting data into table "account_lockup"
input account_lockup_insert_input {
  account_address: String
  block_number: Int
  locked_up_event_id: String
  property_address: String
  value: numeric
}

# aggregate max on columns
type account_lockup_max_fields {
  account_address: String
  block_number: Int
  locked_up_event_id: String
  property_address: String
  value: numeric
}

# order by max() on columns of table "account_lockup"
input account_lockup_max_order_by {
  account_address: order_by
  block_number: order_by
  locked_up_event_id: order_by
  property_address: order_by
  value: order_by
}

# aggregate min on columns
type account_lockup_min_fields {
  account_address: String
  block_number: Int
  locked_up_event_id: String
  property_address: String
  value: numeric
}

# order by min() on columns of table "account_lockup"
input account_lockup_min_order_by {
  account_address: order_by
  block_number: order_by
  locked_up_event_id: order_by
  property_address: order_by
  value: order_by
}

# response of any mutation on the table "account_lockup"
type account_lockup_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [account_lockup!]!
}

# input type for inserting object relation for remote table "account_lockup"
input account_lockup_obj_rel_insert_input {
  data: account_lockup_insert_input!
  on_conflict: account_lockup_on_conflict
}

# on conflict condition type for table "account_lockup"
input account_lockup_on_conflict {
  constraint: account_lockup_constraint!
  update_columns: [account_lockup_update_column!]!
  where: account_lockup_bool_exp
}

# ordering options when selecting data from "account_lockup"
input account_lockup_order_by {
  account_address: order_by
  block_number: order_by
  locked_up_event_id: order_by
  property_address: order_by
  value: order_by
}

# primary key columns input for table: "account_lockup"
input account_lockup_pk_columns_input {
  # account address
  account_address: String!

  # property address
  property_address: String!
}

# select columns of table "account_lockup"
enum account_lockup_select_column {
  # column name
  account_address

  # column name
  block_number

  # column name
  locked_up_event_id

  # column name
  property_address

  # column name
  value
}

# input type for updating data in table "account_lockup"
input account_lockup_set_input {
  account_address: String
  block_number: Int
  locked_up_event_id: String
  property_address: String
  value: numeric
}

# aggregate stddev on columns
type account_lockup_stddev_fields {
  block_number: Float
  value: Float
}

# order by stddev() on columns of table "account_lockup"
input account_lockup_stddev_order_by {
  block_number: order_by
  value: order_by
}

# aggregate stddev_pop on columns
type account_lockup_stddev_pop_fields {
  block_number: Float
  value: Float
}

# order by stddev_pop() on columns of table "account_lockup"
input account_lockup_stddev_pop_order_by {
  block_number: order_by
  value: order_by
}

# aggregate stddev_samp on columns
type account_lockup_stddev_samp_fields {
  block_number: Float
  value: Float
}

# order by stddev_samp() on columns of table "account_lockup"
input account_lockup_stddev_samp_order_by {
  block_number: order_by
  value: order_by
}

# aggregate sum on columns
type account_lockup_sum_fields {
  block_number: Int
  value: numeric
}

# order by sum() on columns of table "account_lockup"
input account_lockup_sum_order_by {
  block_number: order_by
  value: order_by
}

# columns and relationships of "account_lockup_sum_values"
type account_lockup_sum_values {
  account_address: String
  sum_values: numeric
}

# aggregated selection of "account_lockup_sum_values"
type account_lockup_sum_values_aggregate {
  aggregate: account_lockup_sum_values_aggregate_fields
  nodes: [account_lockup_sum_values!]!
}

# aggregate fields of "account_lockup_sum_values"
type account_lockup_sum_values_aggregate_fields {
  avg: account_lockup_sum_values_avg_fields
  count(columns: [account_lockup_sum_values_select_column!], distinct: Boolean): Int
  max: account_lockup_sum_values_max_fields
  min: account_lockup_sum_values_min_fields
  stddev: account_lockup_sum_values_stddev_fields
  stddev_pop: account_lockup_sum_values_stddev_pop_fields
  stddev_samp: account_lockup_sum_values_stddev_samp_fields
  sum: account_lockup_sum_values_sum_fields
  var_pop: account_lockup_sum_values_var_pop_fields
  var_samp: account_lockup_sum_values_var_samp_fields
  variance: account_lockup_sum_values_variance_fields
}

# order by aggregate values of table "account_lockup_sum_values"
input account_lockup_sum_values_aggregate_order_by {
  avg: account_lockup_sum_values_avg_order_by
  count: order_by
  max: account_lockup_sum_values_max_order_by
  min: account_lockup_sum_values_min_order_by
  stddev: account_lockup_sum_values_stddev_order_by
  stddev_pop: account_lockup_sum_values_stddev_pop_order_by
  stddev_samp: account_lockup_sum_values_stddev_samp_order_by
  sum: account_lockup_sum_values_sum_order_by
  var_pop: account_lockup_sum_values_var_pop_order_by
  var_samp: account_lockup_sum_values_var_samp_order_by
  variance: account_lockup_sum_values_variance_order_by
}

# aggregate avg on columns
type account_lockup_sum_values_avg_fields {
  sum_values: Float
}

# order by avg() on columns of table "account_lockup_sum_values"
input account_lockup_sum_values_avg_order_by {
  sum_values: order_by
}

# Boolean expression to filter rows from the table "account_lockup_sum_values". All fields are combined with a logical 'AND'.
input account_lockup_sum_values_bool_exp {
  _and: [account_lockup_sum_values_bool_exp]
  _not: account_lockup_sum_values_bool_exp
  _or: [account_lockup_sum_values_bool_exp]
  account_address: String_comparison_exp
  sum_values: numeric_comparison_exp
}

# aggregate max on columns
type account_lockup_sum_values_max_fields {
  account_address: String
  sum_values: numeric
}

# order by max() on columns of table "account_lockup_sum_values"
input account_lockup_sum_values_max_order_by {
  account_address: order_by
  sum_values: order_by
}

# aggregate min on columns
type account_lockup_sum_values_min_fields {
  account_address: String
  sum_values: numeric
}

# order by min() on columns of table "account_lockup_sum_values"
input account_lockup_sum_values_min_order_by {
  account_address: order_by
  sum_values: order_by
}

# ordering options when selecting data from "account_lockup_sum_values"
input account_lockup_sum_values_order_by {
  account_address: order_by
  sum_values: order_by
}

# select columns of table "account_lockup_sum_values"
enum account_lockup_sum_values_select_column {
  # column name
  account_address

  # column name
  sum_values
}

# aggregate stddev on columns
type account_lockup_sum_values_stddev_fields {
  sum_values: Float
}

# order by stddev() on columns of table "account_lockup_sum_values"
input account_lockup_sum_values_stddev_order_by {
  sum_values: order_by
}

# aggregate stddev_pop on columns
type account_lockup_sum_values_stddev_pop_fields {
  sum_values: Float
}

# order by stddev_pop() on columns of table "account_lockup_sum_values"
input account_lockup_sum_values_stddev_pop_order_by {
  sum_values: order_by
}

# aggregate stddev_samp on columns
type account_lockup_sum_values_stddev_samp_fields {
  sum_values: Float
}

# order by stddev_samp() on columns of table "account_lockup_sum_values"
input account_lockup_sum_values_stddev_samp_order_by {
  sum_values: order_by
}

# aggregate sum on columns
type account_lockup_sum_values_sum_fields {
  sum_values: numeric
}

# order by sum() on columns of table "account_lockup_sum_values"
input account_lockup_sum_values_sum_order_by {
  sum_values: order_by
}

# aggregate var_pop on columns
type account_lockup_sum_values_var_pop_fields {
  sum_values: Float
}

# order by var_pop() on columns of table "account_lockup_sum_values"
input account_lockup_sum_values_var_pop_order_by {
  sum_values: order_by
}

# aggregate var_samp on columns
type account_lockup_sum_values_var_samp_fields {
  sum_values: Float
}

# order by var_samp() on columns of table "account_lockup_sum_values"
input account_lockup_sum_values_var_samp_order_by {
  sum_values: order_by
}

# aggregate variance on columns
type account_lockup_sum_values_variance_fields {
  sum_values: Float
}

# order by variance() on columns of table "account_lockup_sum_values"
input account_lockup_sum_values_variance_order_by {
  sum_values: order_by
}

# update columns of table "account_lockup"
enum account_lockup_update_column {
  # column name
  account_address

  # column name
  block_number

  # column name
  locked_up_event_id

  # column name
  property_address

  # column name
  value
}

# aggregate var_pop on columns
type account_lockup_var_pop_fields {
  block_number: Float
  value: Float
}

# order by var_pop() on columns of table "account_lockup"
input account_lockup_var_pop_order_by {
  block_number: order_by
  value: order_by
}

# aggregate var_samp on columns
type account_lockup_var_samp_fields {
  block_number: Float
  value: Float
}

# order by var_samp() on columns of table "account_lockup"
input account_lockup_var_samp_order_by {
  block_number: order_by
  value: order_by
}

# aggregate variance on columns
type account_lockup_variance_fields {
  block_number: Float
  value: Float
}

# order by variance() on columns of table "account_lockup"
input account_lockup_variance_order_by {
  block_number: order_by
  value: order_by
}

# expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

# Transfer event for a DEV token whose from address or to address is a property address.
#
#
# columns and relationships of "dev_property_transfer"
#
type dev_property_transfer {
  # event block number
  block_number: Int!

  # event id
  event_id: String!

  # from address
  from_address: String!

  # if it is lockup trahsfer, true
  is_lockup: Boolean!

  # event log index
  log_index: Int!

  # event raw data
  raw_data: String!

  # to address
  to_address: String!

  # event transaction index
  transaction_index: Int!

  # value
  value: numeric!
}

# aggregated selection of "dev_property_transfer"
type dev_property_transfer_aggregate {
  aggregate: dev_property_transfer_aggregate_fields
  nodes: [dev_property_transfer!]!
}

# aggregate fields of "dev_property_transfer"
type dev_property_transfer_aggregate_fields {
  avg: dev_property_transfer_avg_fields
  count(columns: [dev_property_transfer_select_column!], distinct: Boolean): Int
  max: dev_property_transfer_max_fields
  min: dev_property_transfer_min_fields
  stddev: dev_property_transfer_stddev_fields
  stddev_pop: dev_property_transfer_stddev_pop_fields
  stddev_samp: dev_property_transfer_stddev_samp_fields
  sum: dev_property_transfer_sum_fields
  var_pop: dev_property_transfer_var_pop_fields
  var_samp: dev_property_transfer_var_samp_fields
  variance: dev_property_transfer_variance_fields
}

# order by aggregate values of table "dev_property_transfer"
input dev_property_transfer_aggregate_order_by {
  avg: dev_property_transfer_avg_order_by
  count: order_by
  max: dev_property_transfer_max_order_by
  min: dev_property_transfer_min_order_by
  stddev: dev_property_transfer_stddev_order_by
  stddev_pop: dev_property_transfer_stddev_pop_order_by
  stddev_samp: dev_property_transfer_stddev_samp_order_by
  sum: dev_property_transfer_sum_order_by
  var_pop: dev_property_transfer_var_pop_order_by
  var_samp: dev_property_transfer_var_samp_order_by
  variance: dev_property_transfer_variance_order_by
}

# input type for inserting array relation for remote table "dev_property_transfer"
input dev_property_transfer_arr_rel_insert_input {
  data: [dev_property_transfer_insert_input!]!
  on_conflict: dev_property_transfer_on_conflict
}

# aggregate avg on columns
type dev_property_transfer_avg_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
  value: Float
}

# order by avg() on columns of table "dev_property_transfer"
input dev_property_transfer_avg_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
  value: order_by
}

# Boolean expression to filter rows from the table "dev_property_transfer". All fields are combined with a logical 'AND'.
input dev_property_transfer_bool_exp {
  _and: [dev_property_transfer_bool_exp]
  _not: dev_property_transfer_bool_exp
  _or: [dev_property_transfer_bool_exp]
  block_number: Int_comparison_exp
  event_id: String_comparison_exp
  from_address: String_comparison_exp
  is_lockup: Boolean_comparison_exp
  log_index: Int_comparison_exp
  raw_data: String_comparison_exp
  to_address: String_comparison_exp
  transaction_index: Int_comparison_exp
  value: numeric_comparison_exp
}

# unique or primary key constraints on table "dev_property_transfer"
enum dev_property_transfer_constraint {
  # unique or primary key constraint
  dev_property_transfer_pkey
}

# input type for incrementing integer column in table "dev_property_transfer"
input dev_property_transfer_inc_input {
  block_number: Int
  log_index: Int
  transaction_index: Int
  value: numeric
}

# input type for inserting data into table "dev_property_transfer"
input dev_property_transfer_insert_input {
  block_number: Int
  event_id: String
  from_address: String
  is_lockup: Boolean
  log_index: Int
  raw_data: String
  to_address: String
  transaction_index: Int
  value: numeric
}

# aggregate max on columns
type dev_property_transfer_max_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  raw_data: String
  to_address: String
  transaction_index: Int
  value: numeric
}

# order by max() on columns of table "dev_property_transfer"
input dev_property_transfer_max_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  raw_data: order_by
  to_address: order_by
  transaction_index: order_by
  value: order_by
}

# aggregate min on columns
type dev_property_transfer_min_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  raw_data: String
  to_address: String
  transaction_index: Int
  value: numeric
}

# order by min() on columns of table "dev_property_transfer"
input dev_property_transfer_min_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  raw_data: order_by
  to_address: order_by
  transaction_index: order_by
  value: order_by
}

# response of any mutation on the table "dev_property_transfer"
type dev_property_transfer_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [dev_property_transfer!]!
}

# input type for inserting object relation for remote table "dev_property_transfer"
input dev_property_transfer_obj_rel_insert_input {
  data: dev_property_transfer_insert_input!
  on_conflict: dev_property_transfer_on_conflict
}

# on conflict condition type for table "dev_property_transfer"
input dev_property_transfer_on_conflict {
  constraint: dev_property_transfer_constraint!
  update_columns: [dev_property_transfer_update_column!]!
  where: dev_property_transfer_bool_exp
}

# ordering options when selecting data from "dev_property_transfer"
input dev_property_transfer_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  is_lockup: order_by
  log_index: order_by
  raw_data: order_by
  to_address: order_by
  transaction_index: order_by
  value: order_by
}

# primary key columns input for table: "dev_property_transfer"
input dev_property_transfer_pk_columns_input {
  # event id
  event_id: String!
}

# select columns of table "dev_property_transfer"
enum dev_property_transfer_select_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  is_lockup

  # column name
  log_index

  # column name
  raw_data

  # column name
  to_address

  # column name
  transaction_index

  # column name
  value
}

# input type for updating data in table "dev_property_transfer"
input dev_property_transfer_set_input {
  block_number: Int
  event_id: String
  from_address: String
  is_lockup: Boolean
  log_index: Int
  raw_data: String
  to_address: String
  transaction_index: Int
  value: numeric
}

# aggregate stddev on columns
type dev_property_transfer_stddev_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
  value: Float
}

# order by stddev() on columns of table "dev_property_transfer"
input dev_property_transfer_stddev_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
  value: order_by
}

# aggregate stddev_pop on columns
type dev_property_transfer_stddev_pop_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
  value: Float
}

# order by stddev_pop() on columns of table "dev_property_transfer"
input dev_property_transfer_stddev_pop_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
  value: order_by
}

# aggregate stddev_samp on columns
type dev_property_transfer_stddev_samp_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
  value: Float
}

# order by stddev_samp() on columns of table "dev_property_transfer"
input dev_property_transfer_stddev_samp_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
  value: order_by
}

# aggregate sum on columns
type dev_property_transfer_sum_fields {
  block_number: Int
  log_index: Int
  transaction_index: Int
  value: numeric
}

# order by sum() on columns of table "dev_property_transfer"
input dev_property_transfer_sum_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
  value: order_by
}

# update columns of table "dev_property_transfer"
enum dev_property_transfer_update_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  is_lockup

  # column name
  log_index

  # column name
  raw_data

  # column name
  to_address

  # column name
  transaction_index

  # column name
  value
}

# aggregate var_pop on columns
type dev_property_transfer_var_pop_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
  value: Float
}

# order by var_pop() on columns of table "dev_property_transfer"
input dev_property_transfer_var_pop_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
  value: order_by
}

# aggregate var_samp on columns
type dev_property_transfer_var_samp_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
  value: Float
}

# order by var_samp() on columns of table "dev_property_transfer"
input dev_property_transfer_var_samp_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
  value: order_by
}

# aggregate variance on columns
type dev_property_transfer_variance_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
  value: Float
}

# order by variance() on columns of table "dev_property_transfer"
input dev_property_transfer_variance_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
  value: order_by
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# lockup event information. records are added each time an lockup is executed.
#
#
# columns and relationships of "lockup_lockedup"
#
type lockup_lockedup {
  # event block number
  block_number: Int!

  # event id
  event_id: String!

  # The address holding the Dev token to be locked up
  from_address: String!

  # event log index
  log_index: Int!

  # lockup destination property address
  property: String!

  # An object relationship
  property_creation: property_factory_create

  # event raw data
  raw_data: String!

  # lockup token value
  token_value: numeric!

  # event transaction index
  transaction_index: Int!
}

# aggregated selection of "lockup_lockedup"
type lockup_lockedup_aggregate {
  aggregate: lockup_lockedup_aggregate_fields
  nodes: [lockup_lockedup!]!
}

# aggregate fields of "lockup_lockedup"
type lockup_lockedup_aggregate_fields {
  avg: lockup_lockedup_avg_fields
  count(columns: [lockup_lockedup_select_column!], distinct: Boolean): Int
  max: lockup_lockedup_max_fields
  min: lockup_lockedup_min_fields
  stddev: lockup_lockedup_stddev_fields
  stddev_pop: lockup_lockedup_stddev_pop_fields
  stddev_samp: lockup_lockedup_stddev_samp_fields
  sum: lockup_lockedup_sum_fields
  var_pop: lockup_lockedup_var_pop_fields
  var_samp: lockup_lockedup_var_samp_fields
  variance: lockup_lockedup_variance_fields
}

# order by aggregate values of table "lockup_lockedup"
input lockup_lockedup_aggregate_order_by {
  avg: lockup_lockedup_avg_order_by
  count: order_by
  max: lockup_lockedup_max_order_by
  min: lockup_lockedup_min_order_by
  stddev: lockup_lockedup_stddev_order_by
  stddev_pop: lockup_lockedup_stddev_pop_order_by
  stddev_samp: lockup_lockedup_stddev_samp_order_by
  sum: lockup_lockedup_sum_order_by
  var_pop: lockup_lockedup_var_pop_order_by
  var_samp: lockup_lockedup_var_samp_order_by
  variance: lockup_lockedup_variance_order_by
}

# input type for inserting array relation for remote table "lockup_lockedup"
input lockup_lockedup_arr_rel_insert_input {
  data: [lockup_lockedup_insert_input!]!
  on_conflict: lockup_lockedup_on_conflict
}

# aggregate avg on columns
type lockup_lockedup_avg_fields {
  block_number: Float
  log_index: Float
  token_value: Float
  transaction_index: Float
}

# order by avg() on columns of table "lockup_lockedup"
input lockup_lockedup_avg_order_by {
  block_number: order_by
  log_index: order_by
  token_value: order_by
  transaction_index: order_by
}

# Boolean expression to filter rows from the table "lockup_lockedup". All fields are combined with a logical 'AND'.
input lockup_lockedup_bool_exp {
  _and: [lockup_lockedup_bool_exp]
  _not: lockup_lockedup_bool_exp
  _or: [lockup_lockedup_bool_exp]
  block_number: Int_comparison_exp
  event_id: String_comparison_exp
  from_address: String_comparison_exp
  log_index: Int_comparison_exp
  property: String_comparison_exp
  property_creation: property_factory_create_bool_exp
  raw_data: String_comparison_exp
  token_value: numeric_comparison_exp
  transaction_index: Int_comparison_exp
}

# unique or primary key constraints on table "lockup_lockedup"
enum lockup_lockedup_constraint {
  # unique or primary key constraint
  lockup_lockedup_pkey
}

# input type for incrementing integer column in table "lockup_lockedup"
input lockup_lockedup_inc_input {
  block_number: Int
  log_index: Int
  token_value: numeric
  transaction_index: Int
}

# input type for inserting data into table "lockup_lockedup"
input lockup_lockedup_insert_input {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  property: String
  property_creation: property_factory_create_obj_rel_insert_input
  raw_data: String
  token_value: numeric
  transaction_index: Int
}

# aggregate max on columns
type lockup_lockedup_max_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  property: String
  raw_data: String
  token_value: numeric
  transaction_index: Int
}

# order by max() on columns of table "lockup_lockedup"
input lockup_lockedup_max_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  property: order_by
  raw_data: order_by
  token_value: order_by
  transaction_index: order_by
}

# aggregate min on columns
type lockup_lockedup_min_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  property: String
  raw_data: String
  token_value: numeric
  transaction_index: Int
}

# order by min() on columns of table "lockup_lockedup"
input lockup_lockedup_min_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  property: order_by
  raw_data: order_by
  token_value: order_by
  transaction_index: order_by
}

# response of any mutation on the table "lockup_lockedup"
type lockup_lockedup_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [lockup_lockedup!]!
}

# input type for inserting object relation for remote table "lockup_lockedup"
input lockup_lockedup_obj_rel_insert_input {
  data: lockup_lockedup_insert_input!
  on_conflict: lockup_lockedup_on_conflict
}

# on conflict condition type for table "lockup_lockedup"
input lockup_lockedup_on_conflict {
  constraint: lockup_lockedup_constraint!
  update_columns: [lockup_lockedup_update_column!]!
  where: lockup_lockedup_bool_exp
}

# ordering options when selecting data from "lockup_lockedup"
input lockup_lockedup_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  property: order_by
  property_creation: property_factory_create_order_by
  raw_data: order_by
  token_value: order_by
  transaction_index: order_by
}

# primary key columns input for table: "lockup_lockedup"
input lockup_lockedup_pk_columns_input {
  # event id
  event_id: String!
}

# select columns of table "lockup_lockedup"
enum lockup_lockedup_select_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  log_index

  # column name
  property

  # column name
  raw_data

  # column name
  token_value

  # column name
  transaction_index
}

# input type for updating data in table "lockup_lockedup"
input lockup_lockedup_set_input {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  property: String
  raw_data: String
  token_value: numeric
  transaction_index: Int
}

# aggregate stddev on columns
type lockup_lockedup_stddev_fields {
  block_number: Float
  log_index: Float
  token_value: Float
  transaction_index: Float
}

# order by stddev() on columns of table "lockup_lockedup"
input lockup_lockedup_stddev_order_by {
  block_number: order_by
  log_index: order_by
  token_value: order_by
  transaction_index: order_by
}

# aggregate stddev_pop on columns
type lockup_lockedup_stddev_pop_fields {
  block_number: Float
  log_index: Float
  token_value: Float
  transaction_index: Float
}

# order by stddev_pop() on columns of table "lockup_lockedup"
input lockup_lockedup_stddev_pop_order_by {
  block_number: order_by
  log_index: order_by
  token_value: order_by
  transaction_index: order_by
}

# aggregate stddev_samp on columns
type lockup_lockedup_stddev_samp_fields {
  block_number: Float
  log_index: Float
  token_value: Float
  transaction_index: Float
}

# order by stddev_samp() on columns of table "lockup_lockedup"
input lockup_lockedup_stddev_samp_order_by {
  block_number: order_by
  log_index: order_by
  token_value: order_by
  transaction_index: order_by
}

# aggregate sum on columns
type lockup_lockedup_sum_fields {
  block_number: Int
  log_index: Int
  token_value: numeric
  transaction_index: Int
}

# order by sum() on columns of table "lockup_lockedup"
input lockup_lockedup_sum_order_by {
  block_number: order_by
  log_index: order_by
  token_value: order_by
  transaction_index: order_by
}

# update columns of table "lockup_lockedup"
enum lockup_lockedup_update_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  log_index

  # column name
  property

  # column name
  raw_data

  # column name
  token_value

  # column name
  transaction_index
}

# aggregate var_pop on columns
type lockup_lockedup_var_pop_fields {
  block_number: Float
  log_index: Float
  token_value: Float
  transaction_index: Float
}

# order by var_pop() on columns of table "lockup_lockedup"
input lockup_lockedup_var_pop_order_by {
  block_number: order_by
  log_index: order_by
  token_value: order_by
  transaction_index: order_by
}

# aggregate var_samp on columns
type lockup_lockedup_var_samp_fields {
  block_number: Float
  log_index: Float
  token_value: Float
  transaction_index: Float
}

# order by var_samp() on columns of table "lockup_lockedup"
input lockup_lockedup_var_samp_order_by {
  block_number: order_by
  log_index: order_by
  token_value: order_by
  transaction_index: order_by
}

# aggregate variance on columns
type lockup_lockedup_variance_fields {
  block_number: Float
  log_index: Float
  token_value: Float
  transaction_index: Float
}

# order by variance() on columns of table "lockup_lockedup"
input lockup_lockedup_variance_order_by {
  block_number: order_by
  log_index: order_by
  token_value: order_by
  transaction_index: order_by
}

# market create event information. records are added each time an market is created.
#
#
# columns and relationships of "market_factory_create"
#
type market_factory_create {
  # event block number
  block_number: Int!

  # An array relationship
  destroyed_metrics(
    # distinct select on columns
    distinct_on: [metrics_factory_destroy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [metrics_factory_destroy_order_by!]

    # filter the rows returned
    where: metrics_factory_destroy_bool_exp
  ): [metrics_factory_destroy!]!

  # An aggregated array relationship
  destroyed_metrics_aggregate(
    # distinct select on columns
    distinct_on: [metrics_factory_destroy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [metrics_factory_destroy_order_by!]

    # filter the rows returned
    where: metrics_factory_destroy_bool_exp
  ): metrics_factory_destroy_aggregate!

  # event id
  event_id: String!

  # the address of the account where you created the market
  from_address: String!

  # event log index
  log_index: Int!

  # the address of the created market
  market: String!

  # An array relationship
  metrics(
    # distinct select on columns
    distinct_on: [metrics_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [metrics_factory_create_order_by!]

    # filter the rows returned
    where: metrics_factory_create_bool_exp
  ): [metrics_factory_create!]!

  # An aggregated array relationship
  metrics_aggregate(
    # distinct select on columns
    distinct_on: [metrics_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [metrics_factory_create_order_by!]

    # filter the rows returned
    where: metrics_factory_create_bool_exp
  ): metrics_factory_create_aggregate!

  # event raw data
  raw_data: String!

  # event transaction index
  transaction_index: Int!
}

# aggregated selection of "market_factory_create"
type market_factory_create_aggregate {
  aggregate: market_factory_create_aggregate_fields
  nodes: [market_factory_create!]!
}

# aggregate fields of "market_factory_create"
type market_factory_create_aggregate_fields {
  avg: market_factory_create_avg_fields
  count(columns: [market_factory_create_select_column!], distinct: Boolean): Int
  max: market_factory_create_max_fields
  min: market_factory_create_min_fields
  stddev: market_factory_create_stddev_fields
  stddev_pop: market_factory_create_stddev_pop_fields
  stddev_samp: market_factory_create_stddev_samp_fields
  sum: market_factory_create_sum_fields
  var_pop: market_factory_create_var_pop_fields
  var_samp: market_factory_create_var_samp_fields
  variance: market_factory_create_variance_fields
}

# order by aggregate values of table "market_factory_create"
input market_factory_create_aggregate_order_by {
  avg: market_factory_create_avg_order_by
  count: order_by
  max: market_factory_create_max_order_by
  min: market_factory_create_min_order_by
  stddev: market_factory_create_stddev_order_by
  stddev_pop: market_factory_create_stddev_pop_order_by
  stddev_samp: market_factory_create_stddev_samp_order_by
  sum: market_factory_create_sum_order_by
  var_pop: market_factory_create_var_pop_order_by
  var_samp: market_factory_create_var_samp_order_by
  variance: market_factory_create_variance_order_by
}

# input type for inserting array relation for remote table "market_factory_create"
input market_factory_create_arr_rel_insert_input {
  data: [market_factory_create_insert_input!]!
  on_conflict: market_factory_create_on_conflict
}

# aggregate avg on columns
type market_factory_create_avg_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by avg() on columns of table "market_factory_create"
input market_factory_create_avg_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# Boolean expression to filter rows from the table "market_factory_create". All fields are combined with a logical 'AND'.
input market_factory_create_bool_exp {
  _and: [market_factory_create_bool_exp]
  _not: market_factory_create_bool_exp
  _or: [market_factory_create_bool_exp]
  block_number: Int_comparison_exp
  destroyed_metrics: metrics_factory_destroy_bool_exp
  event_id: String_comparison_exp
  from_address: String_comparison_exp
  log_index: Int_comparison_exp
  market: String_comparison_exp
  metrics: metrics_factory_create_bool_exp
  raw_data: String_comparison_exp
  transaction_index: Int_comparison_exp
}

# unique or primary key constraints on table "market_factory_create"
enum market_factory_create_constraint {
  # unique or primary key constraint
  market_factory_create_pkey
}

# input type for incrementing integer column in table "market_factory_create"
input market_factory_create_inc_input {
  block_number: Int
  log_index: Int
  transaction_index: Int
}

# input type for inserting data into table "market_factory_create"
input market_factory_create_insert_input {
  block_number: Int
  destroyed_metrics: metrics_factory_destroy_arr_rel_insert_input
  event_id: String
  from_address: String
  log_index: Int
  market: String
  metrics: metrics_factory_create_arr_rel_insert_input
  raw_data: String
  transaction_index: Int
}

# aggregate max on columns
type market_factory_create_max_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  market: String
  raw_data: String
  transaction_index: Int
}

# order by max() on columns of table "market_factory_create"
input market_factory_create_max_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  market: order_by
  raw_data: order_by
  transaction_index: order_by
}

# aggregate min on columns
type market_factory_create_min_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  market: String
  raw_data: String
  transaction_index: Int
}

# order by min() on columns of table "market_factory_create"
input market_factory_create_min_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  market: order_by
  raw_data: order_by
  transaction_index: order_by
}

# response of any mutation on the table "market_factory_create"
type market_factory_create_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [market_factory_create!]!
}

# input type for inserting object relation for remote table "market_factory_create"
input market_factory_create_obj_rel_insert_input {
  data: market_factory_create_insert_input!
  on_conflict: market_factory_create_on_conflict
}

# on conflict condition type for table "market_factory_create"
input market_factory_create_on_conflict {
  constraint: market_factory_create_constraint!
  update_columns: [market_factory_create_update_column!]!
  where: market_factory_create_bool_exp
}

# ordering options when selecting data from "market_factory_create"
input market_factory_create_order_by {
  block_number: order_by
  destroyed_metrics_aggregate: metrics_factory_destroy_aggregate_order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  market: order_by
  metrics_aggregate: metrics_factory_create_aggregate_order_by
  raw_data: order_by
  transaction_index: order_by
}

# primary key columns input for table: "market_factory_create"
input market_factory_create_pk_columns_input {
  # event id
  event_id: String!
}

# select columns of table "market_factory_create"
enum market_factory_create_select_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  log_index

  # column name
  market

  # column name
  raw_data

  # column name
  transaction_index
}

# input type for updating data in table "market_factory_create"
input market_factory_create_set_input {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  market: String
  raw_data: String
  transaction_index: Int
}

# aggregate stddev on columns
type market_factory_create_stddev_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev() on columns of table "market_factory_create"
input market_factory_create_stddev_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate stddev_pop on columns
type market_factory_create_stddev_pop_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev_pop() on columns of table "market_factory_create"
input market_factory_create_stddev_pop_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate stddev_samp on columns
type market_factory_create_stddev_samp_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev_samp() on columns of table "market_factory_create"
input market_factory_create_stddev_samp_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate sum on columns
type market_factory_create_sum_fields {
  block_number: Int
  log_index: Int
  transaction_index: Int
}

# order by sum() on columns of table "market_factory_create"
input market_factory_create_sum_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# update columns of table "market_factory_create"
enum market_factory_create_update_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  log_index

  # column name
  market

  # column name
  raw_data

  # column name
  transaction_index
}

# aggregate var_pop on columns
type market_factory_create_var_pop_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by var_pop() on columns of table "market_factory_create"
input market_factory_create_var_pop_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate var_samp on columns
type market_factory_create_var_samp_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by var_samp() on columns of table "market_factory_create"
input market_factory_create_var_samp_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate variance on columns
type market_factory_create_variance_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by variance() on columns of table "market_factory_create"
input market_factory_create_variance_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# metrics create event information. records are added each time an metrics is created.
#
#
# columns and relationships of "metrics_factory_create"
#
type metrics_factory_create {
  # event block number
  block_number: Int!

  # An object relationship
  destroyed_metrics: metrics_factory_destroy

  # event id
  event_id: String!

  # the address of the market contract that created the metrics
  from_address: String!

  # event log index
  log_index: Int!

  # An object relationship
  market: market_factory_create

  # the address of the created metrics
  metrics: String!

  # event raw data
  raw_data: String!

  # event transaction index
  transaction_index: Int!
}

# aggregated selection of "metrics_factory_create"
type metrics_factory_create_aggregate {
  aggregate: metrics_factory_create_aggregate_fields
  nodes: [metrics_factory_create!]!
}

# aggregate fields of "metrics_factory_create"
type metrics_factory_create_aggregate_fields {
  avg: metrics_factory_create_avg_fields
  count(columns: [metrics_factory_create_select_column!], distinct: Boolean): Int
  max: metrics_factory_create_max_fields
  min: metrics_factory_create_min_fields
  stddev: metrics_factory_create_stddev_fields
  stddev_pop: metrics_factory_create_stddev_pop_fields
  stddev_samp: metrics_factory_create_stddev_samp_fields
  sum: metrics_factory_create_sum_fields
  var_pop: metrics_factory_create_var_pop_fields
  var_samp: metrics_factory_create_var_samp_fields
  variance: metrics_factory_create_variance_fields
}

# order by aggregate values of table "metrics_factory_create"
input metrics_factory_create_aggregate_order_by {
  avg: metrics_factory_create_avg_order_by
  count: order_by
  max: metrics_factory_create_max_order_by
  min: metrics_factory_create_min_order_by
  stddev: metrics_factory_create_stddev_order_by
  stddev_pop: metrics_factory_create_stddev_pop_order_by
  stddev_samp: metrics_factory_create_stddev_samp_order_by
  sum: metrics_factory_create_sum_order_by
  var_pop: metrics_factory_create_var_pop_order_by
  var_samp: metrics_factory_create_var_samp_order_by
  variance: metrics_factory_create_variance_order_by
}

# input type for inserting array relation for remote table "metrics_factory_create"
input metrics_factory_create_arr_rel_insert_input {
  data: [metrics_factory_create_insert_input!]!
  on_conflict: metrics_factory_create_on_conflict
}

# aggregate avg on columns
type metrics_factory_create_avg_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by avg() on columns of table "metrics_factory_create"
input metrics_factory_create_avg_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# Boolean expression to filter rows from the table "metrics_factory_create". All fields are combined with a logical 'AND'.
input metrics_factory_create_bool_exp {
  _and: [metrics_factory_create_bool_exp]
  _not: metrics_factory_create_bool_exp
  _or: [metrics_factory_create_bool_exp]
  block_number: Int_comparison_exp
  destroyed_metrics: metrics_factory_destroy_bool_exp
  event_id: String_comparison_exp
  from_address: String_comparison_exp
  log_index: Int_comparison_exp
  market: market_factory_create_bool_exp
  metrics: String_comparison_exp
  raw_data: String_comparison_exp
  transaction_index: Int_comparison_exp
}

# unique or primary key constraints on table "metrics_factory_create"
enum metrics_factory_create_constraint {
  # unique or primary key constraint
  metrics_factory_create_pkey
}

# input type for incrementing integer column in table "metrics_factory_create"
input metrics_factory_create_inc_input {
  block_number: Int
  log_index: Int
  transaction_index: Int
}

# input type for inserting data into table "metrics_factory_create"
input metrics_factory_create_insert_input {
  block_number: Int
  destroyed_metrics: metrics_factory_destroy_obj_rel_insert_input
  event_id: String
  from_address: String
  log_index: Int
  market: market_factory_create_obj_rel_insert_input
  metrics: String
  raw_data: String
  transaction_index: Int
}

# aggregate max on columns
type metrics_factory_create_max_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  metrics: String
  raw_data: String
  transaction_index: Int
}

# order by max() on columns of table "metrics_factory_create"
input metrics_factory_create_max_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  metrics: order_by
  raw_data: order_by
  transaction_index: order_by
}

# aggregate min on columns
type metrics_factory_create_min_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  metrics: String
  raw_data: String
  transaction_index: Int
}

# order by min() on columns of table "metrics_factory_create"
input metrics_factory_create_min_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  metrics: order_by
  raw_data: order_by
  transaction_index: order_by
}

# response of any mutation on the table "metrics_factory_create"
type metrics_factory_create_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [metrics_factory_create!]!
}

# input type for inserting object relation for remote table "metrics_factory_create"
input metrics_factory_create_obj_rel_insert_input {
  data: metrics_factory_create_insert_input!
  on_conflict: metrics_factory_create_on_conflict
}

# on conflict condition type for table "metrics_factory_create"
input metrics_factory_create_on_conflict {
  constraint: metrics_factory_create_constraint!
  update_columns: [metrics_factory_create_update_column!]!
  where: metrics_factory_create_bool_exp
}

# ordering options when selecting data from "metrics_factory_create"
input metrics_factory_create_order_by {
  block_number: order_by
  destroyed_metrics: metrics_factory_destroy_order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  market: market_factory_create_order_by
  metrics: order_by
  raw_data: order_by
  transaction_index: order_by
}

# primary key columns input for table: "metrics_factory_create"
input metrics_factory_create_pk_columns_input {
  # event id
  event_id: String!
}

# select columns of table "metrics_factory_create"
enum metrics_factory_create_select_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  log_index

  # column name
  metrics

  # column name
  raw_data

  # column name
  transaction_index
}

# input type for updating data in table "metrics_factory_create"
input metrics_factory_create_set_input {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  metrics: String
  raw_data: String
  transaction_index: Int
}

# aggregate stddev on columns
type metrics_factory_create_stddev_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev() on columns of table "metrics_factory_create"
input metrics_factory_create_stddev_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate stddev_pop on columns
type metrics_factory_create_stddev_pop_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev_pop() on columns of table "metrics_factory_create"
input metrics_factory_create_stddev_pop_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate stddev_samp on columns
type metrics_factory_create_stddev_samp_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev_samp() on columns of table "metrics_factory_create"
input metrics_factory_create_stddev_samp_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate sum on columns
type metrics_factory_create_sum_fields {
  block_number: Int
  log_index: Int
  transaction_index: Int
}

# order by sum() on columns of table "metrics_factory_create"
input metrics_factory_create_sum_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# update columns of table "metrics_factory_create"
enum metrics_factory_create_update_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  log_index

  # column name
  metrics

  # column name
  raw_data

  # column name
  transaction_index
}

# aggregate var_pop on columns
type metrics_factory_create_var_pop_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by var_pop() on columns of table "metrics_factory_create"
input metrics_factory_create_var_pop_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate var_samp on columns
type metrics_factory_create_var_samp_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by var_samp() on columns of table "metrics_factory_create"
input metrics_factory_create_var_samp_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate variance on columns
type metrics_factory_create_variance_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by variance() on columns of table "metrics_factory_create"
input metrics_factory_create_variance_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# metrics destroy event information. records are added each time an metrics is disable.
#
#
# columns and relationships of "metrics_factory_destroy"
#
type metrics_factory_destroy {
  # event block number
  block_number: Int!

  # event id
  event_id: String!

  # the address of the market contract that disabled the metrics
  from_address: String!

  # event log index
  log_index: Int!

  # An object relationship
  market: market_factory_create

  # the address of the disabled metrics
  metrics: String!

  # An object relationship
  metrics_creation: metrics_factory_create

  # event raw data
  raw_data: String!

  # event transaction index
  transaction_index: Int!
}

# aggregated selection of "metrics_factory_destroy"
type metrics_factory_destroy_aggregate {
  aggregate: metrics_factory_destroy_aggregate_fields
  nodes: [metrics_factory_destroy!]!
}

# aggregate fields of "metrics_factory_destroy"
type metrics_factory_destroy_aggregate_fields {
  avg: metrics_factory_destroy_avg_fields
  count(columns: [metrics_factory_destroy_select_column!], distinct: Boolean): Int
  max: metrics_factory_destroy_max_fields
  min: metrics_factory_destroy_min_fields
  stddev: metrics_factory_destroy_stddev_fields
  stddev_pop: metrics_factory_destroy_stddev_pop_fields
  stddev_samp: metrics_factory_destroy_stddev_samp_fields
  sum: metrics_factory_destroy_sum_fields
  var_pop: metrics_factory_destroy_var_pop_fields
  var_samp: metrics_factory_destroy_var_samp_fields
  variance: metrics_factory_destroy_variance_fields
}

# order by aggregate values of table "metrics_factory_destroy"
input metrics_factory_destroy_aggregate_order_by {
  avg: metrics_factory_destroy_avg_order_by
  count: order_by
  max: metrics_factory_destroy_max_order_by
  min: metrics_factory_destroy_min_order_by
  stddev: metrics_factory_destroy_stddev_order_by
  stddev_pop: metrics_factory_destroy_stddev_pop_order_by
  stddev_samp: metrics_factory_destroy_stddev_samp_order_by
  sum: metrics_factory_destroy_sum_order_by
  var_pop: metrics_factory_destroy_var_pop_order_by
  var_samp: metrics_factory_destroy_var_samp_order_by
  variance: metrics_factory_destroy_variance_order_by
}

# input type for inserting array relation for remote table "metrics_factory_destroy"
input metrics_factory_destroy_arr_rel_insert_input {
  data: [metrics_factory_destroy_insert_input!]!
  on_conflict: metrics_factory_destroy_on_conflict
}

# aggregate avg on columns
type metrics_factory_destroy_avg_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by avg() on columns of table "metrics_factory_destroy"
input metrics_factory_destroy_avg_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# Boolean expression to filter rows from the table "metrics_factory_destroy". All fields are combined with a logical 'AND'.
input metrics_factory_destroy_bool_exp {
  _and: [metrics_factory_destroy_bool_exp]
  _not: metrics_factory_destroy_bool_exp
  _or: [metrics_factory_destroy_bool_exp]
  block_number: Int_comparison_exp
  event_id: String_comparison_exp
  from_address: String_comparison_exp
  log_index: Int_comparison_exp
  market: market_factory_create_bool_exp
  metrics: String_comparison_exp
  metrics_creation: metrics_factory_create_bool_exp
  raw_data: String_comparison_exp
  transaction_index: Int_comparison_exp
}

# unique or primary key constraints on table "metrics_factory_destroy"
enum metrics_factory_destroy_constraint {
  # unique or primary key constraint
  metrics_factory_destroy_pkey
}

# input type for incrementing integer column in table "metrics_factory_destroy"
input metrics_factory_destroy_inc_input {
  block_number: Int
  log_index: Int
  transaction_index: Int
}

# input type for inserting data into table "metrics_factory_destroy"
input metrics_factory_destroy_insert_input {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  market: market_factory_create_obj_rel_insert_input
  metrics: String
  metrics_creation: metrics_factory_create_obj_rel_insert_input
  raw_data: String
  transaction_index: Int
}

# aggregate max on columns
type metrics_factory_destroy_max_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  metrics: String
  raw_data: String
  transaction_index: Int
}

# order by max() on columns of table "metrics_factory_destroy"
input metrics_factory_destroy_max_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  metrics: order_by
  raw_data: order_by
  transaction_index: order_by
}

# aggregate min on columns
type metrics_factory_destroy_min_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  metrics: String
  raw_data: String
  transaction_index: Int
}

# order by min() on columns of table "metrics_factory_destroy"
input metrics_factory_destroy_min_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  metrics: order_by
  raw_data: order_by
  transaction_index: order_by
}

# response of any mutation on the table "metrics_factory_destroy"
type metrics_factory_destroy_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [metrics_factory_destroy!]!
}

# input type for inserting object relation for remote table "metrics_factory_destroy"
input metrics_factory_destroy_obj_rel_insert_input {
  data: metrics_factory_destroy_insert_input!
  on_conflict: metrics_factory_destroy_on_conflict
}

# on conflict condition type for table "metrics_factory_destroy"
input metrics_factory_destroy_on_conflict {
  constraint: metrics_factory_destroy_constraint!
  update_columns: [metrics_factory_destroy_update_column!]!
  where: metrics_factory_destroy_bool_exp
}

# ordering options when selecting data from "metrics_factory_destroy"
input metrics_factory_destroy_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  market: market_factory_create_order_by
  metrics: order_by
  metrics_creation: metrics_factory_create_order_by
  raw_data: order_by
  transaction_index: order_by
}

# primary key columns input for table: "metrics_factory_destroy"
input metrics_factory_destroy_pk_columns_input {
  # event id
  event_id: String!
}

# select columns of table "metrics_factory_destroy"
enum metrics_factory_destroy_select_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  log_index

  # column name
  metrics

  # column name
  raw_data

  # column name
  transaction_index
}

# input type for updating data in table "metrics_factory_destroy"
input metrics_factory_destroy_set_input {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  metrics: String
  raw_data: String
  transaction_index: Int
}

# aggregate stddev on columns
type metrics_factory_destroy_stddev_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev() on columns of table "metrics_factory_destroy"
input metrics_factory_destroy_stddev_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate stddev_pop on columns
type metrics_factory_destroy_stddev_pop_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev_pop() on columns of table "metrics_factory_destroy"
input metrics_factory_destroy_stddev_pop_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate stddev_samp on columns
type metrics_factory_destroy_stddev_samp_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev_samp() on columns of table "metrics_factory_destroy"
input metrics_factory_destroy_stddev_samp_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate sum on columns
type metrics_factory_destroy_sum_fields {
  block_number: Int
  log_index: Int
  transaction_index: Int
}

# order by sum() on columns of table "metrics_factory_destroy"
input metrics_factory_destroy_sum_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# update columns of table "metrics_factory_destroy"
enum metrics_factory_destroy_update_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  log_index

  # column name
  metrics

  # column name
  raw_data

  # column name
  transaction_index
}

# aggregate var_pop on columns
type metrics_factory_destroy_var_pop_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by var_pop() on columns of table "metrics_factory_destroy"
input metrics_factory_destroy_var_pop_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate var_samp on columns
type metrics_factory_destroy_var_samp_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by var_samp() on columns of table "metrics_factory_destroy"
input metrics_factory_destroy_var_samp_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate variance on columns
type metrics_factory_destroy_variance_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by variance() on columns of table "metrics_factory_destroy"
input metrics_factory_destroy_variance_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# mutation root
type mutation_root {
  # delete data from the table: "account_lockup"
  delete_account_lockup(
    # filter the rows which have to be deleted
    where: account_lockup_bool_exp!
  ): account_lockup_mutation_response

  # delete single row from the table: "account_lockup"
  delete_account_lockup_by_pk(
    # account address
    account_address: String!

    # property address
    property_address: String!
  ): account_lockup

  # delete data from the table: "dev_property_transfer"
  delete_dev_property_transfer(
    # filter the rows which have to be deleted
    where: dev_property_transfer_bool_exp!
  ): dev_property_transfer_mutation_response

  # delete single row from the table: "dev_property_transfer"
  delete_dev_property_transfer_by_pk(
    # event id
    event_id: String!
  ): dev_property_transfer

  # delete data from the table: "lockup_lockedup"
  delete_lockup_lockedup(
    # filter the rows which have to be deleted
    where: lockup_lockedup_bool_exp!
  ): lockup_lockedup_mutation_response

  # delete single row from the table: "lockup_lockedup"
  delete_lockup_lockedup_by_pk(
    # event id
    event_id: String!
  ): lockup_lockedup

  # delete data from the table: "market_factory_create"
  delete_market_factory_create(
    # filter the rows which have to be deleted
    where: market_factory_create_bool_exp!
  ): market_factory_create_mutation_response

  # delete single row from the table: "market_factory_create"
  delete_market_factory_create_by_pk(
    # event id
    event_id: String!
  ): market_factory_create

  # delete data from the table: "metrics_factory_create"
  delete_metrics_factory_create(
    # filter the rows which have to be deleted
    where: metrics_factory_create_bool_exp!
  ): metrics_factory_create_mutation_response

  # delete single row from the table: "metrics_factory_create"
  delete_metrics_factory_create_by_pk(
    # event id
    event_id: String!
  ): metrics_factory_create

  # delete data from the table: "metrics_factory_destroy"
  delete_metrics_factory_destroy(
    # filter the rows which have to be deleted
    where: metrics_factory_destroy_bool_exp!
  ): metrics_factory_destroy_mutation_response

  # delete single row from the table: "metrics_factory_destroy"
  delete_metrics_factory_destroy_by_pk(
    # event id
    event_id: String!
  ): metrics_factory_destroy

  # delete data from the table: "policy_factory_create"
  delete_policy_factory_create(
    # filter the rows which have to be deleted
    where: policy_factory_create_bool_exp!
  ): policy_factory_create_mutation_response

  # delete single row from the table: "policy_factory_create"
  delete_policy_factory_create_by_pk(
    # event id
    event_id: String!
  ): policy_factory_create

  # delete data from the table: "property_authentication"
  delete_property_authentication(
    # filter the rows which have to be deleted
    where: property_authentication_bool_exp!
  ): property_authentication_mutation_response

  # delete single row from the table: "property_authentication"
  delete_property_authentication_by_pk(
    # the metrics address for authentication
    metrics: String!

    # property address
    property: String!
  ): property_authentication

  # delete data from the table: "property_authentication_deleted"
  delete_property_authentication_deleted(
    # filter the rows which have to be deleted
    where: property_authentication_deleted_bool_exp!
  ): property_authentication_deleted_mutation_response

  # delete single row from the table: "property_authentication_deleted"
  delete_property_authentication_deleted_by_pk(
    # disabled metrics address for authentication
    metrics: String!

    # property address
    property: String!
  ): property_authentication_deleted

  # delete data from the table: "property_balance"
  delete_property_balance(
    # filter the rows which have to be deleted
    where: property_balance_bool_exp!
  ): property_balance_mutation_response

  # delete single row from the table: "property_balance"
  delete_property_balance_by_pk(
    # account_address
    account_address: String!

    # property address
    property_address: String!
  ): property_balance

  # delete data from the table: "property_factory_create"
  delete_property_factory_create(
    # filter the rows which have to be deleted
    where: property_factory_create_bool_exp!
  ): property_factory_create_mutation_response

  # delete single row from the table: "property_factory_create"
  delete_property_factory_create_by_pk(
    # event id
    event_id: String!
  ): property_factory_create

  # delete data from the table: "property_lockup"
  delete_property_lockup(
    # filter the rows which have to be deleted
    where: property_lockup_bool_exp!
  ): property_lockup_mutation_response

  # delete single row from the table: "property_lockup"
  delete_property_lockup_by_pk(
    # account address
    account_address: String!

    # property address
    property_address: String!
  ): property_lockup

  # delete data from the table: "property_meta"
  delete_property_meta(
    # filter the rows which have to be deleted
    where: property_meta_bool_exp!
  ): property_meta_mutation_response

  # delete single row from the table: "property_meta"
  delete_property_meta_by_pk(
    # property author address
    author: String!

    # property address
    property: String!
  ): property_meta

  # delete data from the table: "withdraw_property_transfer"
  delete_withdraw_property_transfer(
    # filter the rows which have to be deleted
    where: withdraw_property_transfer_bool_exp!
  ): withdraw_property_transfer_mutation_response

  # delete single row from the table: "withdraw_property_transfer"
  delete_withdraw_property_transfer_by_pk(
    # event id
    event_id: String!
  ): withdraw_property_transfer

  # insert data into the table: "account_lockup"
  insert_account_lockup(
    # the rows to be inserted
    objects: [account_lockup_insert_input!]!

    # on conflict condition
    on_conflict: account_lockup_on_conflict
  ): account_lockup_mutation_response

  # insert a single row into the table: "account_lockup"
  insert_account_lockup_one(
    # the row to be inserted
    object: account_lockup_insert_input!

    # on conflict condition
    on_conflict: account_lockup_on_conflict
  ): account_lockup

  # insert data into the table: "dev_property_transfer"
  insert_dev_property_transfer(
    # the rows to be inserted
    objects: [dev_property_transfer_insert_input!]!

    # on conflict condition
    on_conflict: dev_property_transfer_on_conflict
  ): dev_property_transfer_mutation_response

  # insert a single row into the table: "dev_property_transfer"
  insert_dev_property_transfer_one(
    # the row to be inserted
    object: dev_property_transfer_insert_input!

    # on conflict condition
    on_conflict: dev_property_transfer_on_conflict
  ): dev_property_transfer

  # insert data into the table: "lockup_lockedup"
  insert_lockup_lockedup(
    # the rows to be inserted
    objects: [lockup_lockedup_insert_input!]!

    # on conflict condition
    on_conflict: lockup_lockedup_on_conflict
  ): lockup_lockedup_mutation_response

  # insert a single row into the table: "lockup_lockedup"
  insert_lockup_lockedup_one(
    # the row to be inserted
    object: lockup_lockedup_insert_input!

    # on conflict condition
    on_conflict: lockup_lockedup_on_conflict
  ): lockup_lockedup

  # insert data into the table: "market_factory_create"
  insert_market_factory_create(
    # the rows to be inserted
    objects: [market_factory_create_insert_input!]!

    # on conflict condition
    on_conflict: market_factory_create_on_conflict
  ): market_factory_create_mutation_response

  # insert a single row into the table: "market_factory_create"
  insert_market_factory_create_one(
    # the row to be inserted
    object: market_factory_create_insert_input!

    # on conflict condition
    on_conflict: market_factory_create_on_conflict
  ): market_factory_create

  # insert data into the table: "metrics_factory_create"
  insert_metrics_factory_create(
    # the rows to be inserted
    objects: [metrics_factory_create_insert_input!]!

    # on conflict condition
    on_conflict: metrics_factory_create_on_conflict
  ): metrics_factory_create_mutation_response

  # insert a single row into the table: "metrics_factory_create"
  insert_metrics_factory_create_one(
    # the row to be inserted
    object: metrics_factory_create_insert_input!

    # on conflict condition
    on_conflict: metrics_factory_create_on_conflict
  ): metrics_factory_create

  # insert data into the table: "metrics_factory_destroy"
  insert_metrics_factory_destroy(
    # the rows to be inserted
    objects: [metrics_factory_destroy_insert_input!]!

    # on conflict condition
    on_conflict: metrics_factory_destroy_on_conflict
  ): metrics_factory_destroy_mutation_response

  # insert a single row into the table: "metrics_factory_destroy"
  insert_metrics_factory_destroy_one(
    # the row to be inserted
    object: metrics_factory_destroy_insert_input!

    # on conflict condition
    on_conflict: metrics_factory_destroy_on_conflict
  ): metrics_factory_destroy

  # insert data into the table: "policy_factory_create"
  insert_policy_factory_create(
    # the rows to be inserted
    objects: [policy_factory_create_insert_input!]!

    # on conflict condition
    on_conflict: policy_factory_create_on_conflict
  ): policy_factory_create_mutation_response

  # insert a single row into the table: "policy_factory_create"
  insert_policy_factory_create_one(
    # the row to be inserted
    object: policy_factory_create_insert_input!

    # on conflict condition
    on_conflict: policy_factory_create_on_conflict
  ): policy_factory_create

  # insert data into the table: "property_authentication"
  insert_property_authentication(
    # the rows to be inserted
    objects: [property_authentication_insert_input!]!

    # on conflict condition
    on_conflict: property_authentication_on_conflict
  ): property_authentication_mutation_response

  # insert data into the table: "property_authentication_deleted"
  insert_property_authentication_deleted(
    # the rows to be inserted
    objects: [property_authentication_deleted_insert_input!]!

    # on conflict condition
    on_conflict: property_authentication_deleted_on_conflict
  ): property_authentication_deleted_mutation_response

  # insert a single row into the table: "property_authentication_deleted"
  insert_property_authentication_deleted_one(
    # the row to be inserted
    object: property_authentication_deleted_insert_input!

    # on conflict condition
    on_conflict: property_authentication_deleted_on_conflict
  ): property_authentication_deleted

  # insert a single row into the table: "property_authentication"
  insert_property_authentication_one(
    # the row to be inserted
    object: property_authentication_insert_input!

    # on conflict condition
    on_conflict: property_authentication_on_conflict
  ): property_authentication

  # insert data into the table: "property_balance"
  insert_property_balance(
    # the rows to be inserted
    objects: [property_balance_insert_input!]!

    # on conflict condition
    on_conflict: property_balance_on_conflict
  ): property_balance_mutation_response

  # insert a single row into the table: "property_balance"
  insert_property_balance_one(
    # the row to be inserted
    object: property_balance_insert_input!

    # on conflict condition
    on_conflict: property_balance_on_conflict
  ): property_balance

  # insert data into the table: "property_factory_create"
  insert_property_factory_create(
    # the rows to be inserted
    objects: [property_factory_create_insert_input!]!

    # on conflict condition
    on_conflict: property_factory_create_on_conflict
  ): property_factory_create_mutation_response

  # insert a single row into the table: "property_factory_create"
  insert_property_factory_create_one(
    # the row to be inserted
    object: property_factory_create_insert_input!

    # on conflict condition
    on_conflict: property_factory_create_on_conflict
  ): property_factory_create

  # insert data into the table: "property_lockup"
  insert_property_lockup(
    # the rows to be inserted
    objects: [property_lockup_insert_input!]!

    # on conflict condition
    on_conflict: property_lockup_on_conflict
  ): property_lockup_mutation_response

  # insert a single row into the table: "property_lockup"
  insert_property_lockup_one(
    # the row to be inserted
    object: property_lockup_insert_input!

    # on conflict condition
    on_conflict: property_lockup_on_conflict
  ): property_lockup

  # insert data into the table: "property_meta"
  insert_property_meta(
    # the rows to be inserted
    objects: [property_meta_insert_input!]!

    # on conflict condition
    on_conflict: property_meta_on_conflict
  ): property_meta_mutation_response

  # insert a single row into the table: "property_meta"
  insert_property_meta_one(
    # the row to be inserted
    object: property_meta_insert_input!

    # on conflict condition
    on_conflict: property_meta_on_conflict
  ): property_meta

  # insert data into the table: "withdraw_property_transfer"
  insert_withdraw_property_transfer(
    # the rows to be inserted
    objects: [withdraw_property_transfer_insert_input!]!

    # on conflict condition
    on_conflict: withdraw_property_transfer_on_conflict
  ): withdraw_property_transfer_mutation_response

  # insert a single row into the table: "withdraw_property_transfer"
  insert_withdraw_property_transfer_one(
    # the row to be inserted
    object: withdraw_property_transfer_insert_input!

    # on conflict condition
    on_conflict: withdraw_property_transfer_on_conflict
  ): withdraw_property_transfer

  # update data of the table: "account_lockup"
  update_account_lockup(
    # increments the integer columns with given value of the filtered values
    _inc: account_lockup_inc_input

    # sets the columns of the filtered rows to the given values
    _set: account_lockup_set_input

    # filter the rows which have to be updated
    where: account_lockup_bool_exp!
  ): account_lockup_mutation_response

  # update single row of the table: "account_lockup"
  update_account_lockup_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: account_lockup_inc_input

    # sets the columns of the filtered rows to the given values
    _set: account_lockup_set_input
    pk_columns: account_lockup_pk_columns_input!
  ): account_lockup

  # update data of the table: "dev_property_transfer"
  update_dev_property_transfer(
    # increments the integer columns with given value of the filtered values
    _inc: dev_property_transfer_inc_input

    # sets the columns of the filtered rows to the given values
    _set: dev_property_transfer_set_input

    # filter the rows which have to be updated
    where: dev_property_transfer_bool_exp!
  ): dev_property_transfer_mutation_response

  # update single row of the table: "dev_property_transfer"
  update_dev_property_transfer_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: dev_property_transfer_inc_input

    # sets the columns of the filtered rows to the given values
    _set: dev_property_transfer_set_input
    pk_columns: dev_property_transfer_pk_columns_input!
  ): dev_property_transfer

  # update data of the table: "lockup_lockedup"
  update_lockup_lockedup(
    # increments the integer columns with given value of the filtered values
    _inc: lockup_lockedup_inc_input

    # sets the columns of the filtered rows to the given values
    _set: lockup_lockedup_set_input

    # filter the rows which have to be updated
    where: lockup_lockedup_bool_exp!
  ): lockup_lockedup_mutation_response

  # update single row of the table: "lockup_lockedup"
  update_lockup_lockedup_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: lockup_lockedup_inc_input

    # sets the columns of the filtered rows to the given values
    _set: lockup_lockedup_set_input
    pk_columns: lockup_lockedup_pk_columns_input!
  ): lockup_lockedup

  # update data of the table: "market_factory_create"
  update_market_factory_create(
    # increments the integer columns with given value of the filtered values
    _inc: market_factory_create_inc_input

    # sets the columns of the filtered rows to the given values
    _set: market_factory_create_set_input

    # filter the rows which have to be updated
    where: market_factory_create_bool_exp!
  ): market_factory_create_mutation_response

  # update single row of the table: "market_factory_create"
  update_market_factory_create_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: market_factory_create_inc_input

    # sets the columns of the filtered rows to the given values
    _set: market_factory_create_set_input
    pk_columns: market_factory_create_pk_columns_input!
  ): market_factory_create

  # update data of the table: "metrics_factory_create"
  update_metrics_factory_create(
    # increments the integer columns with given value of the filtered values
    _inc: metrics_factory_create_inc_input

    # sets the columns of the filtered rows to the given values
    _set: metrics_factory_create_set_input

    # filter the rows which have to be updated
    where: metrics_factory_create_bool_exp!
  ): metrics_factory_create_mutation_response

  # update single row of the table: "metrics_factory_create"
  update_metrics_factory_create_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: metrics_factory_create_inc_input

    # sets the columns of the filtered rows to the given values
    _set: metrics_factory_create_set_input
    pk_columns: metrics_factory_create_pk_columns_input!
  ): metrics_factory_create

  # update data of the table: "metrics_factory_destroy"
  update_metrics_factory_destroy(
    # increments the integer columns with given value of the filtered values
    _inc: metrics_factory_destroy_inc_input

    # sets the columns of the filtered rows to the given values
    _set: metrics_factory_destroy_set_input

    # filter the rows which have to be updated
    where: metrics_factory_destroy_bool_exp!
  ): metrics_factory_destroy_mutation_response

  # update single row of the table: "metrics_factory_destroy"
  update_metrics_factory_destroy_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: metrics_factory_destroy_inc_input

    # sets the columns of the filtered rows to the given values
    _set: metrics_factory_destroy_set_input
    pk_columns: metrics_factory_destroy_pk_columns_input!
  ): metrics_factory_destroy

  # update data of the table: "policy_factory_create"
  update_policy_factory_create(
    # increments the integer columns with given value of the filtered values
    _inc: policy_factory_create_inc_input

    # sets the columns of the filtered rows to the given values
    _set: policy_factory_create_set_input

    # filter the rows which have to be updated
    where: policy_factory_create_bool_exp!
  ): policy_factory_create_mutation_response

  # update single row of the table: "policy_factory_create"
  update_policy_factory_create_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: policy_factory_create_inc_input

    # sets the columns of the filtered rows to the given values
    _set: policy_factory_create_set_input
    pk_columns: policy_factory_create_pk_columns_input!
  ): policy_factory_create

  # update data of the table: "property_authentication"
  update_property_authentication(
    # increments the integer columns with given value of the filtered values
    _inc: property_authentication_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_authentication_set_input

    # filter the rows which have to be updated
    where: property_authentication_bool_exp!
  ): property_authentication_mutation_response

  # update single row of the table: "property_authentication"
  update_property_authentication_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: property_authentication_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_authentication_set_input
    pk_columns: property_authentication_pk_columns_input!
  ): property_authentication

  # update data of the table: "property_authentication_deleted"
  update_property_authentication_deleted(
    # increments the integer columns with given value of the filtered values
    _inc: property_authentication_deleted_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_authentication_deleted_set_input

    # filter the rows which have to be updated
    where: property_authentication_deleted_bool_exp!
  ): property_authentication_deleted_mutation_response

  # update single row of the table: "property_authentication_deleted"
  update_property_authentication_deleted_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: property_authentication_deleted_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_authentication_deleted_set_input
    pk_columns: property_authentication_deleted_pk_columns_input!
  ): property_authentication_deleted

  # update data of the table: "property_balance"
  update_property_balance(
    # increments the integer columns with given value of the filtered values
    _inc: property_balance_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_balance_set_input

    # filter the rows which have to be updated
    where: property_balance_bool_exp!
  ): property_balance_mutation_response

  # update single row of the table: "property_balance"
  update_property_balance_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: property_balance_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_balance_set_input
    pk_columns: property_balance_pk_columns_input!
  ): property_balance

  # update data of the table: "property_factory_create"
  update_property_factory_create(
    # increments the integer columns with given value of the filtered values
    _inc: property_factory_create_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_factory_create_set_input

    # filter the rows which have to be updated
    where: property_factory_create_bool_exp!
  ): property_factory_create_mutation_response

  # update single row of the table: "property_factory_create"
  update_property_factory_create_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: property_factory_create_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_factory_create_set_input
    pk_columns: property_factory_create_pk_columns_input!
  ): property_factory_create

  # update data of the table: "property_lockup"
  update_property_lockup(
    # increments the integer columns with given value of the filtered values
    _inc: property_lockup_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_lockup_set_input

    # filter the rows which have to be updated
    where: property_lockup_bool_exp!
  ): property_lockup_mutation_response

  # update single row of the table: "property_lockup"
  update_property_lockup_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: property_lockup_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_lockup_set_input
    pk_columns: property_lockup_pk_columns_input!
  ): property_lockup

  # update data of the table: "property_meta"
  update_property_meta(
    # increments the integer columns with given value of the filtered values
    _inc: property_meta_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_meta_set_input

    # filter the rows which have to be updated
    where: property_meta_bool_exp!
  ): property_meta_mutation_response

  # update single row of the table: "property_meta"
  update_property_meta_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: property_meta_inc_input

    # sets the columns of the filtered rows to the given values
    _set: property_meta_set_input
    pk_columns: property_meta_pk_columns_input!
  ): property_meta

  # update data of the table: "withdraw_property_transfer"
  update_withdraw_property_transfer(
    # increments the integer columns with given value of the filtered values
    _inc: withdraw_property_transfer_inc_input

    # sets the columns of the filtered rows to the given values
    _set: withdraw_property_transfer_set_input

    # filter the rows which have to be updated
    where: withdraw_property_transfer_bool_exp!
  ): withdraw_property_transfer_mutation_response

  # update single row of the table: "withdraw_property_transfer"
  update_withdraw_property_transfer_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: withdraw_property_transfer_inc_input

    # sets the columns of the filtered rows to the given values
    _set: withdraw_property_transfer_set_input
    pk_columns: withdraw_property_transfer_pk_columns_input!
  ): withdraw_property_transfer
}

scalar numeric

# expression to compare columns of type numeric. All fields are combined with logical 'AND'.
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# policy create event information. records are added each time a new policy is created.
#
#
# columns and relationships of "policy_factory_create"
#
type policy_factory_create {
  # event block number
  block_number: Int!

  # event id
  event_id: String!

  # author address of the policy
  from_address: String!

  # event log index
  log_index: Int!

  # policy address
  policy_address: String!

  # event raw data
  raw_data: String!

  # event transaction index
  transaction_index: Int!
}

# aggregated selection of "policy_factory_create"
type policy_factory_create_aggregate {
  aggregate: policy_factory_create_aggregate_fields
  nodes: [policy_factory_create!]!
}

# aggregate fields of "policy_factory_create"
type policy_factory_create_aggregate_fields {
  avg: policy_factory_create_avg_fields
  count(columns: [policy_factory_create_select_column!], distinct: Boolean): Int
  max: policy_factory_create_max_fields
  min: policy_factory_create_min_fields
  stddev: policy_factory_create_stddev_fields
  stddev_pop: policy_factory_create_stddev_pop_fields
  stddev_samp: policy_factory_create_stddev_samp_fields
  sum: policy_factory_create_sum_fields
  var_pop: policy_factory_create_var_pop_fields
  var_samp: policy_factory_create_var_samp_fields
  variance: policy_factory_create_variance_fields
}

# order by aggregate values of table "policy_factory_create"
input policy_factory_create_aggregate_order_by {
  avg: policy_factory_create_avg_order_by
  count: order_by
  max: policy_factory_create_max_order_by
  min: policy_factory_create_min_order_by
  stddev: policy_factory_create_stddev_order_by
  stddev_pop: policy_factory_create_stddev_pop_order_by
  stddev_samp: policy_factory_create_stddev_samp_order_by
  sum: policy_factory_create_sum_order_by
  var_pop: policy_factory_create_var_pop_order_by
  var_samp: policy_factory_create_var_samp_order_by
  variance: policy_factory_create_variance_order_by
}

# input type for inserting array relation for remote table "policy_factory_create"
input policy_factory_create_arr_rel_insert_input {
  data: [policy_factory_create_insert_input!]!
  on_conflict: policy_factory_create_on_conflict
}

# aggregate avg on columns
type policy_factory_create_avg_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by avg() on columns of table "policy_factory_create"
input policy_factory_create_avg_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# Boolean expression to filter rows from the table "policy_factory_create". All fields are combined with a logical 'AND'.
input policy_factory_create_bool_exp {
  _and: [policy_factory_create_bool_exp]
  _not: policy_factory_create_bool_exp
  _or: [policy_factory_create_bool_exp]
  block_number: Int_comparison_exp
  event_id: String_comparison_exp
  from_address: String_comparison_exp
  log_index: Int_comparison_exp
  policy_address: String_comparison_exp
  raw_data: String_comparison_exp
  transaction_index: Int_comparison_exp
}

# unique or primary key constraints on table "policy_factory_create"
enum policy_factory_create_constraint {
  # unique or primary key constraint
  policy_factory_create_pkey
}

# input type for incrementing integer column in table "policy_factory_create"
input policy_factory_create_inc_input {
  block_number: Int
  log_index: Int
  transaction_index: Int
}

# input type for inserting data into table "policy_factory_create"
input policy_factory_create_insert_input {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  policy_address: String
  raw_data: String
  transaction_index: Int
}

# aggregate max on columns
type policy_factory_create_max_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  policy_address: String
  raw_data: String
  transaction_index: Int
}

# order by max() on columns of table "policy_factory_create"
input policy_factory_create_max_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  policy_address: order_by
  raw_data: order_by
  transaction_index: order_by
}

# aggregate min on columns
type policy_factory_create_min_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  policy_address: String
  raw_data: String
  transaction_index: Int
}

# order by min() on columns of table "policy_factory_create"
input policy_factory_create_min_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  policy_address: order_by
  raw_data: order_by
  transaction_index: order_by
}

# response of any mutation on the table "policy_factory_create"
type policy_factory_create_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [policy_factory_create!]!
}

# input type for inserting object relation for remote table "policy_factory_create"
input policy_factory_create_obj_rel_insert_input {
  data: policy_factory_create_insert_input!
  on_conflict: policy_factory_create_on_conflict
}

# on conflict condition type for table "policy_factory_create"
input policy_factory_create_on_conflict {
  constraint: policy_factory_create_constraint!
  update_columns: [policy_factory_create_update_column!]!
  where: policy_factory_create_bool_exp
}

# ordering options when selecting data from "policy_factory_create"
input policy_factory_create_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  policy_address: order_by
  raw_data: order_by
  transaction_index: order_by
}

# primary key columns input for table: "policy_factory_create"
input policy_factory_create_pk_columns_input {
  # event id
  event_id: String!
}

# select columns of table "policy_factory_create"
enum policy_factory_create_select_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  log_index

  # column name
  policy_address

  # column name
  raw_data

  # column name
  transaction_index
}

# input type for updating data in table "policy_factory_create"
input policy_factory_create_set_input {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  policy_address: String
  raw_data: String
  transaction_index: Int
}

# aggregate stddev on columns
type policy_factory_create_stddev_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev() on columns of table "policy_factory_create"
input policy_factory_create_stddev_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate stddev_pop on columns
type policy_factory_create_stddev_pop_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev_pop() on columns of table "policy_factory_create"
input policy_factory_create_stddev_pop_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate stddev_samp on columns
type policy_factory_create_stddev_samp_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev_samp() on columns of table "policy_factory_create"
input policy_factory_create_stddev_samp_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate sum on columns
type policy_factory_create_sum_fields {
  block_number: Int
  log_index: Int
  transaction_index: Int
}

# order by sum() on columns of table "policy_factory_create"
input policy_factory_create_sum_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# update columns of table "policy_factory_create"
enum policy_factory_create_update_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  log_index

  # column name
  policy_address

  # column name
  raw_data

  # column name
  transaction_index
}

# aggregate var_pop on columns
type policy_factory_create_var_pop_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by var_pop() on columns of table "policy_factory_create"
input policy_factory_create_var_pop_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate var_samp on columns
type policy_factory_create_var_samp_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by var_samp() on columns of table "policy_factory_create"
input policy_factory_create_var_samp_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate variance on columns
type policy_factory_create_variance_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by variance() on columns of table "policy_factory_create"
input policy_factory_create_variance_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# the authentication information for the property.
#
#
# columns and relationships of "property_authentication"
#
type property_authentication {
  # authentication id
  authentication_id: String!

  # the block number of the authentication process
  block_number: Int!

  # authenticated market address
  market: String!

  # An object relationship
  market_creation: market_factory_create

  # the metrics address for authentication
  metrics: String!

  # property address
  property: String!

  # An object relationship
  property_creation: property_factory_create

  # An object relationship
  property_meta: property_meta
}

# aggregated selection of "property_authentication"
type property_authentication_aggregate {
  aggregate: property_authentication_aggregate_fields
  nodes: [property_authentication!]!
}

# aggregate fields of "property_authentication"
type property_authentication_aggregate_fields {
  avg: property_authentication_avg_fields
  count(columns: [property_authentication_select_column!], distinct: Boolean): Int
  max: property_authentication_max_fields
  min: property_authentication_min_fields
  stddev: property_authentication_stddev_fields
  stddev_pop: property_authentication_stddev_pop_fields
  stddev_samp: property_authentication_stddev_samp_fields
  sum: property_authentication_sum_fields
  var_pop: property_authentication_var_pop_fields
  var_samp: property_authentication_var_samp_fields
  variance: property_authentication_variance_fields
}

# order by aggregate values of table "property_authentication"
input property_authentication_aggregate_order_by {
  avg: property_authentication_avg_order_by
  count: order_by
  max: property_authentication_max_order_by
  min: property_authentication_min_order_by
  stddev: property_authentication_stddev_order_by
  stddev_pop: property_authentication_stddev_pop_order_by
  stddev_samp: property_authentication_stddev_samp_order_by
  sum: property_authentication_sum_order_by
  var_pop: property_authentication_var_pop_order_by
  var_samp: property_authentication_var_samp_order_by
  variance: property_authentication_variance_order_by
}

# input type for inserting array relation for remote table "property_authentication"
input property_authentication_arr_rel_insert_input {
  data: [property_authentication_insert_input!]!
  on_conflict: property_authentication_on_conflict
}

# aggregate avg on columns
type property_authentication_avg_fields {
  block_number: Float
}

# order by avg() on columns of table "property_authentication"
input property_authentication_avg_order_by {
  block_number: order_by
}

# Boolean expression to filter rows from the table "property_authentication". All fields are combined with a logical 'AND'.
input property_authentication_bool_exp {
  _and: [property_authentication_bool_exp]
  _not: property_authentication_bool_exp
  _or: [property_authentication_bool_exp]
  authentication_id: String_comparison_exp
  block_number: Int_comparison_exp
  market: String_comparison_exp
  market_creation: market_factory_create_bool_exp
  metrics: String_comparison_exp
  property: String_comparison_exp
  property_creation: property_factory_create_bool_exp
  property_meta: property_meta_bool_exp
}

# unique or primary key constraints on table "property_authentication"
enum property_authentication_constraint {
  # unique or primary key constraint
  property_authentication_pkey
}

# The property de-authentication information.
#
#
# columns and relationships of "property_authentication_deleted"
#
type property_authentication_deleted {
  # disabled authentication id
  authentication_id: String!

  # block number where the de-authentication process was executed
  block_number: Int!

  # de-authenticated market address
  market: String!

  # An object relationship
  market_creation: market_factory_create

  # disabled metrics address for authentication
  metrics: String!

  # property address
  property: String!

  # An object relationship
  property_creation: property_factory_create
}

# aggregated selection of "property_authentication_deleted"
type property_authentication_deleted_aggregate {
  aggregate: property_authentication_deleted_aggregate_fields
  nodes: [property_authentication_deleted!]!
}

# aggregate fields of "property_authentication_deleted"
type property_authentication_deleted_aggregate_fields {
  avg: property_authentication_deleted_avg_fields
  count(columns: [property_authentication_deleted_select_column!], distinct: Boolean): Int
  max: property_authentication_deleted_max_fields
  min: property_authentication_deleted_min_fields
  stddev: property_authentication_deleted_stddev_fields
  stddev_pop: property_authentication_deleted_stddev_pop_fields
  stddev_samp: property_authentication_deleted_stddev_samp_fields
  sum: property_authentication_deleted_sum_fields
  var_pop: property_authentication_deleted_var_pop_fields
  var_samp: property_authentication_deleted_var_samp_fields
  variance: property_authentication_deleted_variance_fields
}

# order by aggregate values of table "property_authentication_deleted"
input property_authentication_deleted_aggregate_order_by {
  avg: property_authentication_deleted_avg_order_by
  count: order_by
  max: property_authentication_deleted_max_order_by
  min: property_authentication_deleted_min_order_by
  stddev: property_authentication_deleted_stddev_order_by
  stddev_pop: property_authentication_deleted_stddev_pop_order_by
  stddev_samp: property_authentication_deleted_stddev_samp_order_by
  sum: property_authentication_deleted_sum_order_by
  var_pop: property_authentication_deleted_var_pop_order_by
  var_samp: property_authentication_deleted_var_samp_order_by
  variance: property_authentication_deleted_variance_order_by
}

# input type for inserting array relation for remote table "property_authentication_deleted"
input property_authentication_deleted_arr_rel_insert_input {
  data: [property_authentication_deleted_insert_input!]!
  on_conflict: property_authentication_deleted_on_conflict
}

# aggregate avg on columns
type property_authentication_deleted_avg_fields {
  block_number: Float
}

# order by avg() on columns of table "property_authentication_deleted"
input property_authentication_deleted_avg_order_by {
  block_number: order_by
}

# Boolean expression to filter rows from the table
# "property_authentication_deleted". All fields are combined with a logical 'AND'.
input property_authentication_deleted_bool_exp {
  _and: [property_authentication_deleted_bool_exp]
  _not: property_authentication_deleted_bool_exp
  _or: [property_authentication_deleted_bool_exp]
  authentication_id: String_comparison_exp
  block_number: Int_comparison_exp
  market: String_comparison_exp
  market_creation: market_factory_create_bool_exp
  metrics: String_comparison_exp
  property: String_comparison_exp
  property_creation: property_factory_create_bool_exp
}

# unique or primary key constraints on table "property_authentication_deleted"
enum property_authentication_deleted_constraint {
  # unique or primary key constraint
  property_authentication_deleted_pkey
}

# input type for incrementing integer column in table "property_authentication_deleted"
input property_authentication_deleted_inc_input {
  block_number: Int
}

# input type for inserting data into table "property_authentication_deleted"
input property_authentication_deleted_insert_input {
  authentication_id: String
  block_number: Int
  market: String
  market_creation: market_factory_create_obj_rel_insert_input
  metrics: String
  property: String
  property_creation: property_factory_create_obj_rel_insert_input
}

# aggregate max on columns
type property_authentication_deleted_max_fields {
  authentication_id: String
  block_number: Int
  market: String
  metrics: String
  property: String
}

# order by max() on columns of table "property_authentication_deleted"
input property_authentication_deleted_max_order_by {
  authentication_id: order_by
  block_number: order_by
  market: order_by
  metrics: order_by
  property: order_by
}

# aggregate min on columns
type property_authentication_deleted_min_fields {
  authentication_id: String
  block_number: Int
  market: String
  metrics: String
  property: String
}

# order by min() on columns of table "property_authentication_deleted"
input property_authentication_deleted_min_order_by {
  authentication_id: order_by
  block_number: order_by
  market: order_by
  metrics: order_by
  property: order_by
}

# response of any mutation on the table "property_authentication_deleted"
type property_authentication_deleted_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [property_authentication_deleted!]!
}

# input type for inserting object relation for remote table "property_authentication_deleted"
input property_authentication_deleted_obj_rel_insert_input {
  data: property_authentication_deleted_insert_input!
  on_conflict: property_authentication_deleted_on_conflict
}

# on conflict condition type for table "property_authentication_deleted"
input property_authentication_deleted_on_conflict {
  constraint: property_authentication_deleted_constraint!
  update_columns: [property_authentication_deleted_update_column!]!
  where: property_authentication_deleted_bool_exp
}

# ordering options when selecting data from "property_authentication_deleted"
input property_authentication_deleted_order_by {
  authentication_id: order_by
  block_number: order_by
  market: order_by
  market_creation: market_factory_create_order_by
  metrics: order_by
  property: order_by
  property_creation: property_factory_create_order_by
}

# primary key columns input for table: "property_authentication_deleted"
input property_authentication_deleted_pk_columns_input {
  # disabled metrics address for authentication
  metrics: String!

  # property address
  property: String!
}

# select columns of table "property_authentication_deleted"
enum property_authentication_deleted_select_column {
  # column name
  authentication_id

  # column name
  block_number

  # column name
  market

  # column name
  metrics

  # column name
  property
}

# input type for updating data in table "property_authentication_deleted"
input property_authentication_deleted_set_input {
  authentication_id: String
  block_number: Int
  market: String
  metrics: String
  property: String
}

# aggregate stddev on columns
type property_authentication_deleted_stddev_fields {
  block_number: Float
}

# order by stddev() on columns of table "property_authentication_deleted"
input property_authentication_deleted_stddev_order_by {
  block_number: order_by
}

# aggregate stddev_pop on columns
type property_authentication_deleted_stddev_pop_fields {
  block_number: Float
}

# order by stddev_pop() on columns of table "property_authentication_deleted"
input property_authentication_deleted_stddev_pop_order_by {
  block_number: order_by
}

# aggregate stddev_samp on columns
type property_authentication_deleted_stddev_samp_fields {
  block_number: Float
}

# order by stddev_samp() on columns of table "property_authentication_deleted"
input property_authentication_deleted_stddev_samp_order_by {
  block_number: order_by
}

# aggregate sum on columns
type property_authentication_deleted_sum_fields {
  block_number: Int
}

# order by sum() on columns of table "property_authentication_deleted"
input property_authentication_deleted_sum_order_by {
  block_number: order_by
}

# update columns of table "property_authentication_deleted"
enum property_authentication_deleted_update_column {
  # column name
  authentication_id

  # column name
  block_number

  # column name
  market

  # column name
  metrics

  # column name
  property
}

# aggregate var_pop on columns
type property_authentication_deleted_var_pop_fields {
  block_number: Float
}

# order by var_pop() on columns of table "property_authentication_deleted"
input property_authentication_deleted_var_pop_order_by {
  block_number: order_by
}

# aggregate var_samp on columns
type property_authentication_deleted_var_samp_fields {
  block_number: Float
}

# order by var_samp() on columns of table "property_authentication_deleted"
input property_authentication_deleted_var_samp_order_by {
  block_number: order_by
}

# aggregate variance on columns
type property_authentication_deleted_variance_fields {
  block_number: Float
}

# order by variance() on columns of table "property_authentication_deleted"
input property_authentication_deleted_variance_order_by {
  block_number: order_by
}

# input type for incrementing integer column in table "property_authentication"
input property_authentication_inc_input {
  block_number: Int
}

# input type for inserting data into table "property_authentication"
input property_authentication_insert_input {
  authentication_id: String
  block_number: Int
  market: String
  market_creation: market_factory_create_obj_rel_insert_input
  metrics: String
  property: String
  property_creation: property_factory_create_obj_rel_insert_input
  property_meta: property_meta_obj_rel_insert_input
}

# aggregate max on columns
type property_authentication_max_fields {
  authentication_id: String
  block_number: Int
  market: String
  metrics: String
  property: String
}

# order by max() on columns of table "property_authentication"
input property_authentication_max_order_by {
  authentication_id: order_by
  block_number: order_by
  market: order_by
  metrics: order_by
  property: order_by
}

# aggregate min on columns
type property_authentication_min_fields {
  authentication_id: String
  block_number: Int
  market: String
  metrics: String
  property: String
}

# order by min() on columns of table "property_authentication"
input property_authentication_min_order_by {
  authentication_id: order_by
  block_number: order_by
  market: order_by
  metrics: order_by
  property: order_by
}

# response of any mutation on the table "property_authentication"
type property_authentication_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [property_authentication!]!
}

# input type for inserting object relation for remote table "property_authentication"
input property_authentication_obj_rel_insert_input {
  data: property_authentication_insert_input!
  on_conflict: property_authentication_on_conflict
}

# on conflict condition type for table "property_authentication"
input property_authentication_on_conflict {
  constraint: property_authentication_constraint!
  update_columns: [property_authentication_update_column!]!
  where: property_authentication_bool_exp
}

# ordering options when selecting data from "property_authentication"
input property_authentication_order_by {
  authentication_id: order_by
  block_number: order_by
  market: order_by
  market_creation: market_factory_create_order_by
  metrics: order_by
  property: order_by
  property_creation: property_factory_create_order_by
  property_meta: property_meta_order_by
}

# primary key columns input for table: "property_authentication"
input property_authentication_pk_columns_input {
  # the metrics address for authentication
  metrics: String!

  # property address
  property: String!
}

# select columns of table "property_authentication"
enum property_authentication_select_column {
  # column name
  authentication_id

  # column name
  block_number

  # column name
  market

  # column name
  metrics

  # column name
  property
}

# input type for updating data in table "property_authentication"
input property_authentication_set_input {
  authentication_id: String
  block_number: Int
  market: String
  metrics: String
  property: String
}

# aggregate stddev on columns
type property_authentication_stddev_fields {
  block_number: Float
}

# order by stddev() on columns of table "property_authentication"
input property_authentication_stddev_order_by {
  block_number: order_by
}

# aggregate stddev_pop on columns
type property_authentication_stddev_pop_fields {
  block_number: Float
}

# order by stddev_pop() on columns of table "property_authentication"
input property_authentication_stddev_pop_order_by {
  block_number: order_by
}

# aggregate stddev_samp on columns
type property_authentication_stddev_samp_fields {
  block_number: Float
}

# order by stddev_samp() on columns of table "property_authentication"
input property_authentication_stddev_samp_order_by {
  block_number: order_by
}

# aggregate sum on columns
type property_authentication_sum_fields {
  block_number: Int
}

# order by sum() on columns of table "property_authentication"
input property_authentication_sum_order_by {
  block_number: order_by
}

# update columns of table "property_authentication"
enum property_authentication_update_column {
  # column name
  authentication_id

  # column name
  block_number

  # column name
  market

  # column name
  metrics

  # column name
  property
}

# aggregate var_pop on columns
type property_authentication_var_pop_fields {
  block_number: Float
}

# order by var_pop() on columns of table "property_authentication"
input property_authentication_var_pop_order_by {
  block_number: order_by
}

# aggregate var_samp on columns
type property_authentication_var_samp_fields {
  block_number: Float
}

# order by var_samp() on columns of table "property_authentication"
input property_authentication_var_samp_order_by {
  block_number: order_by
}

# aggregate variance on columns
type property_authentication_variance_fields {
  block_number: Float
}

# order by variance() on columns of table "property_authentication"
input property_authentication_variance_order_by {
  block_number: order_by
}

# property token balance
#
#
# columns and relationships of "property_balance"
#
type property_balance {
  # account_address
  account_address: String!

  # property token balance
  balance: numeric!

  # block number
  block_number: Int!

  # if account_address is author, true
  is_author: Boolean!

  # property address
  property_address: String!
}

# aggregated selection of "property_balance"
type property_balance_aggregate {
  aggregate: property_balance_aggregate_fields
  nodes: [property_balance!]!
}

# aggregate fields of "property_balance"
type property_balance_aggregate_fields {
  avg: property_balance_avg_fields
  count(columns: [property_balance_select_column!], distinct: Boolean): Int
  max: property_balance_max_fields
  min: property_balance_min_fields
  stddev: property_balance_stddev_fields
  stddev_pop: property_balance_stddev_pop_fields
  stddev_samp: property_balance_stddev_samp_fields
  sum: property_balance_sum_fields
  var_pop: property_balance_var_pop_fields
  var_samp: property_balance_var_samp_fields
  variance: property_balance_variance_fields
}

# order by aggregate values of table "property_balance"
input property_balance_aggregate_order_by {
  avg: property_balance_avg_order_by
  count: order_by
  max: property_balance_max_order_by
  min: property_balance_min_order_by
  stddev: property_balance_stddev_order_by
  stddev_pop: property_balance_stddev_pop_order_by
  stddev_samp: property_balance_stddev_samp_order_by
  sum: property_balance_sum_order_by
  var_pop: property_balance_var_pop_order_by
  var_samp: property_balance_var_samp_order_by
  variance: property_balance_variance_order_by
}

# input type for inserting array relation for remote table "property_balance"
input property_balance_arr_rel_insert_input {
  data: [property_balance_insert_input!]!
  on_conflict: property_balance_on_conflict
}

# aggregate avg on columns
type property_balance_avg_fields {
  balance: Float
  block_number: Float
}

# order by avg() on columns of table "property_balance"
input property_balance_avg_order_by {
  balance: order_by
  block_number: order_by
}

# Boolean expression to filter rows from the table "property_balance". All fields are combined with a logical 'AND'.
input property_balance_bool_exp {
  _and: [property_balance_bool_exp]
  _not: property_balance_bool_exp
  _or: [property_balance_bool_exp]
  account_address: String_comparison_exp
  balance: numeric_comparison_exp
  block_number: Int_comparison_exp
  is_author: Boolean_comparison_exp
  property_address: String_comparison_exp
}

# unique or primary key constraints on table "property_balance"
enum property_balance_constraint {
  # unique or primary key constraint
  property_balance_pkey
}

# input type for incrementing integer column in table "property_balance"
input property_balance_inc_input {
  balance: numeric
  block_number: Int
}

# input type for inserting data into table "property_balance"
input property_balance_insert_input {
  account_address: String
  balance: numeric
  block_number: Int
  is_author: Boolean
  property_address: String
}

# aggregate max on columns
type property_balance_max_fields {
  account_address: String
  balance: numeric
  block_number: Int
  property_address: String
}

# order by max() on columns of table "property_balance"
input property_balance_max_order_by {
  account_address: order_by
  balance: order_by
  block_number: order_by
  property_address: order_by
}

# aggregate min on columns
type property_balance_min_fields {
  account_address: String
  balance: numeric
  block_number: Int
  property_address: String
}

# order by min() on columns of table "property_balance"
input property_balance_min_order_by {
  account_address: order_by
  balance: order_by
  block_number: order_by
  property_address: order_by
}

# response of any mutation on the table "property_balance"
type property_balance_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [property_balance!]!
}

# input type for inserting object relation for remote table "property_balance"
input property_balance_obj_rel_insert_input {
  data: property_balance_insert_input!
  on_conflict: property_balance_on_conflict
}

# on conflict condition type for table "property_balance"
input property_balance_on_conflict {
  constraint: property_balance_constraint!
  update_columns: [property_balance_update_column!]!
  where: property_balance_bool_exp
}

# ordering options when selecting data from "property_balance"
input property_balance_order_by {
  account_address: order_by
  balance: order_by
  block_number: order_by
  is_author: order_by
  property_address: order_by
}

# primary key columns input for table: "property_balance"
input property_balance_pk_columns_input {
  # account_address
  account_address: String!

  # property address
  property_address: String!
}

# select columns of table "property_balance"
enum property_balance_select_column {
  # column name
  account_address

  # column name
  balance

  # column name
  block_number

  # column name
  is_author

  # column name
  property_address
}

# input type for updating data in table "property_balance"
input property_balance_set_input {
  account_address: String
  balance: numeric
  block_number: Int
  is_author: Boolean
  property_address: String
}

# aggregate stddev on columns
type property_balance_stddev_fields {
  balance: Float
  block_number: Float
}

# order by stddev() on columns of table "property_balance"
input property_balance_stddev_order_by {
  balance: order_by
  block_number: order_by
}

# aggregate stddev_pop on columns
type property_balance_stddev_pop_fields {
  balance: Float
  block_number: Float
}

# order by stddev_pop() on columns of table "property_balance"
input property_balance_stddev_pop_order_by {
  balance: order_by
  block_number: order_by
}

# aggregate stddev_samp on columns
type property_balance_stddev_samp_fields {
  balance: Float
  block_number: Float
}

# order by stddev_samp() on columns of table "property_balance"
input property_balance_stddev_samp_order_by {
  balance: order_by
  block_number: order_by
}

# aggregate sum on columns
type property_balance_sum_fields {
  balance: numeric
  block_number: Int
}

# order by sum() on columns of table "property_balance"
input property_balance_sum_order_by {
  balance: order_by
  block_number: order_by
}

# update columns of table "property_balance"
enum property_balance_update_column {
  # column name
  account_address

  # column name
  balance

  # column name
  block_number

  # column name
  is_author

  # column name
  property_address
}

# aggregate var_pop on columns
type property_balance_var_pop_fields {
  balance: Float
  block_number: Float
}

# order by var_pop() on columns of table "property_balance"
input property_balance_var_pop_order_by {
  balance: order_by
  block_number: order_by
}

# aggregate var_samp on columns
type property_balance_var_samp_fields {
  balance: Float
  block_number: Float
}

# order by var_samp() on columns of table "property_balance"
input property_balance_var_samp_order_by {
  balance: order_by
  block_number: order_by
}

# aggregate variance on columns
type property_balance_variance_fields {
  balance: Float
  block_number: Float
}

# order by variance() on columns of table "property_balance"
input property_balance_variance_order_by {
  balance: order_by
  block_number: order_by
}

# property create event information. records are added each time an property is created.
#
#
# columns and relationships of "property_factory_create"
#
type property_factory_create {
  # An array relationship
  authentication(
    # distinct select on columns
    distinct_on: [property_authentication_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_authentication_order_by!]

    # filter the rows returned
    where: property_authentication_bool_exp
  ): [property_authentication!]!

  # An aggregated array relationship
  authentication_aggregate(
    # distinct select on columns
    distinct_on: [property_authentication_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_authentication_order_by!]

    # filter the rows returned
    where: property_authentication_bool_exp
  ): property_authentication_aggregate!

  # event block number
  block_number: Int!

  # An object relationship
  current_lockup: property_lockup_sum_values

  # An array relationship
  deleted_authentication(
    # distinct select on columns
    distinct_on: [property_authentication_deleted_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_authentication_deleted_order_by!]

    # filter the rows returned
    where: property_authentication_deleted_bool_exp
  ): [property_authentication_deleted!]!

  # An aggregated array relationship
  deleted_authentication_aggregate(
    # distinct select on columns
    distinct_on: [property_authentication_deleted_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_authentication_deleted_order_by!]

    # filter the rows returned
    where: property_authentication_deleted_bool_exp
  ): property_authentication_deleted_aggregate!

  # event id
  event_id: String!

  # the address of the account where you created the property
  from_address: String!

  # An array relationship
  lockedup(
    # distinct select on columns
    distinct_on: [lockup_lockedup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lockup_lockedup_order_by!]

    # filter the rows returned
    where: lockup_lockedup_bool_exp
  ): [lockup_lockedup!]!

  # An aggregated array relationship
  lockedup_aggregate(
    # distinct select on columns
    distinct_on: [lockup_lockedup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lockup_lockedup_order_by!]

    # filter the rows returned
    where: lockup_lockedup_bool_exp
  ): lockup_lockedup_aggregate!

  # event log index
  log_index: Int!

  # the address of the created property
  property: String!

  # An array relationship
  property_creation(
    # distinct select on columns
    distinct_on: [lockup_lockedup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lockup_lockedup_order_by!]

    # filter the rows returned
    where: lockup_lockedup_bool_exp
  ): [lockup_lockedup!]!

  # An aggregated array relationship
  property_creation_aggregate(
    # distinct select on columns
    distinct_on: [lockup_lockedup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lockup_lockedup_order_by!]

    # filter the rows returned
    where: lockup_lockedup_bool_exp
  ): lockup_lockedup_aggregate!

  # event raw data
  raw_data: String!

  # event transaction index
  transaction_index: Int!
}

# aggregated selection of "property_factory_create"
type property_factory_create_aggregate {
  aggregate: property_factory_create_aggregate_fields
  nodes: [property_factory_create!]!
}

# aggregate fields of "property_factory_create"
type property_factory_create_aggregate_fields {
  avg: property_factory_create_avg_fields
  count(columns: [property_factory_create_select_column!], distinct: Boolean): Int
  max: property_factory_create_max_fields
  min: property_factory_create_min_fields
  stddev: property_factory_create_stddev_fields
  stddev_pop: property_factory_create_stddev_pop_fields
  stddev_samp: property_factory_create_stddev_samp_fields
  sum: property_factory_create_sum_fields
  var_pop: property_factory_create_var_pop_fields
  var_samp: property_factory_create_var_samp_fields
  variance: property_factory_create_variance_fields
}

# order by aggregate values of table "property_factory_create"
input property_factory_create_aggregate_order_by {
  avg: property_factory_create_avg_order_by
  count: order_by
  max: property_factory_create_max_order_by
  min: property_factory_create_min_order_by
  stddev: property_factory_create_stddev_order_by
  stddev_pop: property_factory_create_stddev_pop_order_by
  stddev_samp: property_factory_create_stddev_samp_order_by
  sum: property_factory_create_sum_order_by
  var_pop: property_factory_create_var_pop_order_by
  var_samp: property_factory_create_var_samp_order_by
  variance: property_factory_create_variance_order_by
}

# input type for inserting array relation for remote table "property_factory_create"
input property_factory_create_arr_rel_insert_input {
  data: [property_factory_create_insert_input!]!
  on_conflict: property_factory_create_on_conflict
}

# aggregate avg on columns
type property_factory_create_avg_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by avg() on columns of table "property_factory_create"
input property_factory_create_avg_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# Boolean expression to filter rows from the table "property_factory_create". All fields are combined with a logical 'AND'.
input property_factory_create_bool_exp {
  _and: [property_factory_create_bool_exp]
  _not: property_factory_create_bool_exp
  _or: [property_factory_create_bool_exp]
  authentication: property_authentication_bool_exp
  block_number: Int_comparison_exp
  current_lockup: property_lockup_sum_values_bool_exp
  deleted_authentication: property_authentication_deleted_bool_exp
  event_id: String_comparison_exp
  from_address: String_comparison_exp
  lockedup: lockup_lockedup_bool_exp
  log_index: Int_comparison_exp
  property: String_comparison_exp
  property_creation: lockup_lockedup_bool_exp
  raw_data: String_comparison_exp
  transaction_index: Int_comparison_exp
}

# unique or primary key constraints on table "property_factory_create"
enum property_factory_create_constraint {
  # unique or primary key constraint
  property_factory_create_pkey
}

# input type for incrementing integer column in table "property_factory_create"
input property_factory_create_inc_input {
  block_number: Int
  log_index: Int
  transaction_index: Int
}

# input type for inserting data into table "property_factory_create"
input property_factory_create_insert_input {
  authentication: property_authentication_arr_rel_insert_input
  block_number: Int
  deleted_authentication: property_authentication_deleted_arr_rel_insert_input
  event_id: String
  from_address: String
  lockedup: lockup_lockedup_arr_rel_insert_input
  log_index: Int
  property: String
  property_creation: lockup_lockedup_arr_rel_insert_input
  raw_data: String
  transaction_index: Int
}

# aggregate max on columns
type property_factory_create_max_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  property: String
  raw_data: String
  transaction_index: Int
}

# order by max() on columns of table "property_factory_create"
input property_factory_create_max_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  property: order_by
  raw_data: order_by
  transaction_index: order_by
}

# aggregate min on columns
type property_factory_create_min_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  property: String
  raw_data: String
  transaction_index: Int
}

# order by min() on columns of table "property_factory_create"
input property_factory_create_min_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  property: order_by
  raw_data: order_by
  transaction_index: order_by
}

# response of any mutation on the table "property_factory_create"
type property_factory_create_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [property_factory_create!]!
}

# input type for inserting object relation for remote table "property_factory_create"
input property_factory_create_obj_rel_insert_input {
  data: property_factory_create_insert_input!
  on_conflict: property_factory_create_on_conflict
}

# on conflict condition type for table "property_factory_create"
input property_factory_create_on_conflict {
  constraint: property_factory_create_constraint!
  update_columns: [property_factory_create_update_column!]!
  where: property_factory_create_bool_exp
}

# ordering options when selecting data from "property_factory_create"
input property_factory_create_order_by {
  authentication_aggregate: property_authentication_aggregate_order_by
  block_number: order_by
  current_lockup: property_lockup_sum_values_order_by
  deleted_authentication_aggregate: property_authentication_deleted_aggregate_order_by
  event_id: order_by
  from_address: order_by
  lockedup_aggregate: lockup_lockedup_aggregate_order_by
  log_index: order_by
  property: order_by
  property_creation_aggregate: lockup_lockedup_aggregate_order_by
  raw_data: order_by
  transaction_index: order_by
}

# primary key columns input for table: "property_factory_create"
input property_factory_create_pk_columns_input {
  # event id
  event_id: String!
}

# select columns of table "property_factory_create"
enum property_factory_create_select_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  log_index

  # column name
  property

  # column name
  raw_data

  # column name
  transaction_index
}

# input type for updating data in table "property_factory_create"
input property_factory_create_set_input {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  property: String
  raw_data: String
  transaction_index: Int
}

# aggregate stddev on columns
type property_factory_create_stddev_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev() on columns of table "property_factory_create"
input property_factory_create_stddev_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate stddev_pop on columns
type property_factory_create_stddev_pop_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev_pop() on columns of table "property_factory_create"
input property_factory_create_stddev_pop_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate stddev_samp on columns
type property_factory_create_stddev_samp_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev_samp() on columns of table "property_factory_create"
input property_factory_create_stddev_samp_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate sum on columns
type property_factory_create_sum_fields {
  block_number: Int
  log_index: Int
  transaction_index: Int
}

# order by sum() on columns of table "property_factory_create"
input property_factory_create_sum_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# update columns of table "property_factory_create"
enum property_factory_create_update_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  log_index

  # column name
  property

  # column name
  raw_data

  # column name
  transaction_index
}

# aggregate var_pop on columns
type property_factory_create_var_pop_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by var_pop() on columns of table "property_factory_create"
input property_factory_create_var_pop_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate var_samp on columns
type property_factory_create_var_samp_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by var_samp() on columns of table "property_factory_create"
input property_factory_create_var_samp_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate variance on columns
type property_factory_create_variance_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by variance() on columns of table "property_factory_create"
input property_factory_create_variance_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# current property lockuped information.
#
#
# columns and relationships of "property_lockup"
#
type property_lockup {
  # account address
  account_address: String!

  # block number
  block_number: Int!

  # event id of lockup_lockedup
  locked_up_event_id: String!

  # property address
  property_address: String!

  # lockuped value
  value: numeric!
}

# aggregated selection of "property_lockup"
type property_lockup_aggregate {
  aggregate: property_lockup_aggregate_fields
  nodes: [property_lockup!]!
}

# aggregate fields of "property_lockup"
type property_lockup_aggregate_fields {
  avg: property_lockup_avg_fields
  count(columns: [property_lockup_select_column!], distinct: Boolean): Int
  max: property_lockup_max_fields
  min: property_lockup_min_fields
  stddev: property_lockup_stddev_fields
  stddev_pop: property_lockup_stddev_pop_fields
  stddev_samp: property_lockup_stddev_samp_fields
  sum: property_lockup_sum_fields
  var_pop: property_lockup_var_pop_fields
  var_samp: property_lockup_var_samp_fields
  variance: property_lockup_variance_fields
}

# order by aggregate values of table "property_lockup"
input property_lockup_aggregate_order_by {
  avg: property_lockup_avg_order_by
  count: order_by
  max: property_lockup_max_order_by
  min: property_lockup_min_order_by
  stddev: property_lockup_stddev_order_by
  stddev_pop: property_lockup_stddev_pop_order_by
  stddev_samp: property_lockup_stddev_samp_order_by
  sum: property_lockup_sum_order_by
  var_pop: property_lockup_var_pop_order_by
  var_samp: property_lockup_var_samp_order_by
  variance: property_lockup_variance_order_by
}

# input type for inserting array relation for remote table "property_lockup"
input property_lockup_arr_rel_insert_input {
  data: [property_lockup_insert_input!]!
  on_conflict: property_lockup_on_conflict
}

# aggregate avg on columns
type property_lockup_avg_fields {
  block_number: Float
  value: Float
}

# order by avg() on columns of table "property_lockup"
input property_lockup_avg_order_by {
  block_number: order_by
  value: order_by
}

# Boolean expression to filter rows from the table "property_lockup". All fields are combined with a logical 'AND'.
input property_lockup_bool_exp {
  _and: [property_lockup_bool_exp]
  _not: property_lockup_bool_exp
  _or: [property_lockup_bool_exp]
  account_address: String_comparison_exp
  block_number: Int_comparison_exp
  locked_up_event_id: String_comparison_exp
  property_address: String_comparison_exp
  value: numeric_comparison_exp
}

# unique or primary key constraints on table "property_lockup"
enum property_lockup_constraint {
  # unique or primary key constraint
  property_lockup_pkey
}

# input type for incrementing integer column in table "property_lockup"
input property_lockup_inc_input {
  block_number: Int
  value: numeric
}

# input type for inserting data into table "property_lockup"
input property_lockup_insert_input {
  account_address: String
  block_number: Int
  locked_up_event_id: String
  property_address: String
  value: numeric
}

# aggregate max on columns
type property_lockup_max_fields {
  account_address: String
  block_number: Int
  locked_up_event_id: String
  property_address: String
  value: numeric
}

# order by max() on columns of table "property_lockup"
input property_lockup_max_order_by {
  account_address: order_by
  block_number: order_by
  locked_up_event_id: order_by
  property_address: order_by
  value: order_by
}

# aggregate min on columns
type property_lockup_min_fields {
  account_address: String
  block_number: Int
  locked_up_event_id: String
  property_address: String
  value: numeric
}

# order by min() on columns of table "property_lockup"
input property_lockup_min_order_by {
  account_address: order_by
  block_number: order_by
  locked_up_event_id: order_by
  property_address: order_by
  value: order_by
}

# response of any mutation on the table "property_lockup"
type property_lockup_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [property_lockup!]!
}

# input type for inserting object relation for remote table "property_lockup"
input property_lockup_obj_rel_insert_input {
  data: property_lockup_insert_input!
  on_conflict: property_lockup_on_conflict
}

# on conflict condition type for table "property_lockup"
input property_lockup_on_conflict {
  constraint: property_lockup_constraint!
  update_columns: [property_lockup_update_column!]!
  where: property_lockup_bool_exp
}

# ordering options when selecting data from "property_lockup"
input property_lockup_order_by {
  account_address: order_by
  block_number: order_by
  locked_up_event_id: order_by
  property_address: order_by
  value: order_by
}

# primary key columns input for table: "property_lockup"
input property_lockup_pk_columns_input {
  # account address
  account_address: String!

  # property address
  property_address: String!
}

# select columns of table "property_lockup"
enum property_lockup_select_column {
  # column name
  account_address

  # column name
  block_number

  # column name
  locked_up_event_id

  # column name
  property_address

  # column name
  value
}

# input type for updating data in table "property_lockup"
input property_lockup_set_input {
  account_address: String
  block_number: Int
  locked_up_event_id: String
  property_address: String
  value: numeric
}

# aggregate stddev on columns
type property_lockup_stddev_fields {
  block_number: Float
  value: Float
}

# order by stddev() on columns of table "property_lockup"
input property_lockup_stddev_order_by {
  block_number: order_by
  value: order_by
}

# aggregate stddev_pop on columns
type property_lockup_stddev_pop_fields {
  block_number: Float
  value: Float
}

# order by stddev_pop() on columns of table "property_lockup"
input property_lockup_stddev_pop_order_by {
  block_number: order_by
  value: order_by
}

# aggregate stddev_samp on columns
type property_lockup_stddev_samp_fields {
  block_number: Float
  value: Float
}

# order by stddev_samp() on columns of table "property_lockup"
input property_lockup_stddev_samp_order_by {
  block_number: order_by
  value: order_by
}

# aggregate sum on columns
type property_lockup_sum_fields {
  block_number: Int
  value: numeric
}

# order by sum() on columns of table "property_lockup"
input property_lockup_sum_order_by {
  block_number: order_by
  value: order_by
}

# columns and relationships of "property_lockup_sum_values"
type property_lockup_sum_values {
  property_address: String
  sum_values: numeric
}

# aggregated selection of "property_lockup_sum_values"
type property_lockup_sum_values_aggregate {
  aggregate: property_lockup_sum_values_aggregate_fields
  nodes: [property_lockup_sum_values!]!
}

# aggregate fields of "property_lockup_sum_values"
type property_lockup_sum_values_aggregate_fields {
  avg: property_lockup_sum_values_avg_fields
  count(columns: [property_lockup_sum_values_select_column!], distinct: Boolean): Int
  max: property_lockup_sum_values_max_fields
  min: property_lockup_sum_values_min_fields
  stddev: property_lockup_sum_values_stddev_fields
  stddev_pop: property_lockup_sum_values_stddev_pop_fields
  stddev_samp: property_lockup_sum_values_stddev_samp_fields
  sum: property_lockup_sum_values_sum_fields
  var_pop: property_lockup_sum_values_var_pop_fields
  var_samp: property_lockup_sum_values_var_samp_fields
  variance: property_lockup_sum_values_variance_fields
}

# order by aggregate values of table "property_lockup_sum_values"
input property_lockup_sum_values_aggregate_order_by {
  avg: property_lockup_sum_values_avg_order_by
  count: order_by
  max: property_lockup_sum_values_max_order_by
  min: property_lockup_sum_values_min_order_by
  stddev: property_lockup_sum_values_stddev_order_by
  stddev_pop: property_lockup_sum_values_stddev_pop_order_by
  stddev_samp: property_lockup_sum_values_stddev_samp_order_by
  sum: property_lockup_sum_values_sum_order_by
  var_pop: property_lockup_sum_values_var_pop_order_by
  var_samp: property_lockup_sum_values_var_samp_order_by
  variance: property_lockup_sum_values_variance_order_by
}

# aggregate avg on columns
type property_lockup_sum_values_avg_fields {
  sum_values: Float
}

# order by avg() on columns of table "property_lockup_sum_values"
input property_lockup_sum_values_avg_order_by {
  sum_values: order_by
}

# Boolean expression to filter rows from the table "property_lockup_sum_values". All fields are combined with a logical 'AND'.
input property_lockup_sum_values_bool_exp {
  _and: [property_lockup_sum_values_bool_exp]
  _not: property_lockup_sum_values_bool_exp
  _or: [property_lockup_sum_values_bool_exp]
  property_address: String_comparison_exp
  sum_values: numeric_comparison_exp
}

# aggregate max on columns
type property_lockup_sum_values_max_fields {
  property_address: String
  sum_values: numeric
}

# order by max() on columns of table "property_lockup_sum_values"
input property_lockup_sum_values_max_order_by {
  property_address: order_by
  sum_values: order_by
}

# aggregate min on columns
type property_lockup_sum_values_min_fields {
  property_address: String
  sum_values: numeric
}

# order by min() on columns of table "property_lockup_sum_values"
input property_lockup_sum_values_min_order_by {
  property_address: order_by
  sum_values: order_by
}

# ordering options when selecting data from "property_lockup_sum_values"
input property_lockup_sum_values_order_by {
  property_address: order_by
  sum_values: order_by
}

# select columns of table "property_lockup_sum_values"
enum property_lockup_sum_values_select_column {
  # column name
  property_address

  # column name
  sum_values
}

# aggregate stddev on columns
type property_lockup_sum_values_stddev_fields {
  sum_values: Float
}

# order by stddev() on columns of table "property_lockup_sum_values"
input property_lockup_sum_values_stddev_order_by {
  sum_values: order_by
}

# aggregate stddev_pop on columns
type property_lockup_sum_values_stddev_pop_fields {
  sum_values: Float
}

# order by stddev_pop() on columns of table "property_lockup_sum_values"
input property_lockup_sum_values_stddev_pop_order_by {
  sum_values: order_by
}

# aggregate stddev_samp on columns
type property_lockup_sum_values_stddev_samp_fields {
  sum_values: Float
}

# order by stddev_samp() on columns of table "property_lockup_sum_values"
input property_lockup_sum_values_stddev_samp_order_by {
  sum_values: order_by
}

# aggregate sum on columns
type property_lockup_sum_values_sum_fields {
  sum_values: numeric
}

# order by sum() on columns of table "property_lockup_sum_values"
input property_lockup_sum_values_sum_order_by {
  sum_values: order_by
}

# aggregate var_pop on columns
type property_lockup_sum_values_var_pop_fields {
  sum_values: Float
}

# order by var_pop() on columns of table "property_lockup_sum_values"
input property_lockup_sum_values_var_pop_order_by {
  sum_values: order_by
}

# aggregate var_samp on columns
type property_lockup_sum_values_var_samp_fields {
  sum_values: Float
}

# order by var_samp() on columns of table "property_lockup_sum_values"
input property_lockup_sum_values_var_samp_order_by {
  sum_values: order_by
}

# aggregate variance on columns
type property_lockup_sum_values_variance_fields {
  sum_values: Float
}

# order by variance() on columns of table "property_lockup_sum_values"
input property_lockup_sum_values_variance_order_by {
  sum_values: order_by
}

# update columns of table "property_lockup"
enum property_lockup_update_column {
  # column name
  account_address

  # column name
  block_number

  # column name
  locked_up_event_id

  # column name
  property_address

  # column name
  value
}

# aggregate var_pop on columns
type property_lockup_var_pop_fields {
  block_number: Float
  value: Float
}

# order by var_pop() on columns of table "property_lockup"
input property_lockup_var_pop_order_by {
  block_number: order_by
  value: order_by
}

# aggregate var_samp on columns
type property_lockup_var_samp_fields {
  block_number: Float
  value: Float
}

# order by var_samp() on columns of table "property_lockup"
input property_lockup_var_samp_order_by {
  block_number: order_by
  value: order_by
}

# aggregate variance on columns
type property_lockup_variance_fields {
  block_number: Float
  value: Float
}

# order by variance() on columns of table "property_lockup"
input property_lockup_variance_order_by {
  block_number: order_by
  value: order_by
}

# property meta-information.
#
#
# columns and relationships of "property_meta"
#
type property_meta {
  # property author address
  author: String!

  # the block number from which the property was created
  block_number: Int!

  # An array relationship
  lockup(
    # distinct select on columns
    distinct_on: [property_lockup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_lockup_order_by!]

    # filter the rows returned
    where: property_lockup_bool_exp
  ): [property_lockup!]!

  # An aggregated array relationship
  lockup_aggregate(
    # distinct select on columns
    distinct_on: [property_lockup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_lockup_order_by!]

    # filter the rows returned
    where: property_lockup_bool_exp
  ): property_lockup_aggregate!

  # property name
  name: String!

  # property address
  property: String!

  # the address of the account where you created the property
  sender: String!

  # property symbol
  symbol: String!
  total_supply: numeric!
}

# aggregated selection of "property_meta"
type property_meta_aggregate {
  aggregate: property_meta_aggregate_fields
  nodes: [property_meta!]!
}

# aggregate fields of "property_meta"
type property_meta_aggregate_fields {
  avg: property_meta_avg_fields
  count(columns: [property_meta_select_column!], distinct: Boolean): Int
  max: property_meta_max_fields
  min: property_meta_min_fields
  stddev: property_meta_stddev_fields
  stddev_pop: property_meta_stddev_pop_fields
  stddev_samp: property_meta_stddev_samp_fields
  sum: property_meta_sum_fields
  var_pop: property_meta_var_pop_fields
  var_samp: property_meta_var_samp_fields
  variance: property_meta_variance_fields
}

# order by aggregate values of table "property_meta"
input property_meta_aggregate_order_by {
  avg: property_meta_avg_order_by
  count: order_by
  max: property_meta_max_order_by
  min: property_meta_min_order_by
  stddev: property_meta_stddev_order_by
  stddev_pop: property_meta_stddev_pop_order_by
  stddev_samp: property_meta_stddev_samp_order_by
  sum: property_meta_sum_order_by
  var_pop: property_meta_var_pop_order_by
  var_samp: property_meta_var_samp_order_by
  variance: property_meta_variance_order_by
}

# input type for inserting array relation for remote table "property_meta"
input property_meta_arr_rel_insert_input {
  data: [property_meta_insert_input!]!
  on_conflict: property_meta_on_conflict
}

# aggregate avg on columns
type property_meta_avg_fields {
  block_number: Float
  total_supply: Float
}

# order by avg() on columns of table "property_meta"
input property_meta_avg_order_by {
  block_number: order_by
  total_supply: order_by
}

# Boolean expression to filter rows from the table "property_meta". All fields are combined with a logical 'AND'.
input property_meta_bool_exp {
  _and: [property_meta_bool_exp]
  _not: property_meta_bool_exp
  _or: [property_meta_bool_exp]
  author: String_comparison_exp
  block_number: Int_comparison_exp
  lockup: property_lockup_bool_exp
  name: String_comparison_exp
  property: String_comparison_exp
  sender: String_comparison_exp
  symbol: String_comparison_exp
  total_supply: numeric_comparison_exp
}

# unique or primary key constraints on table "property_meta"
enum property_meta_constraint {
  # unique or primary key constraint
  property_meta_pkey
}

# input type for incrementing integer column in table "property_meta"
input property_meta_inc_input {
  block_number: Int
  total_supply: numeric
}

# input type for inserting data into table "property_meta"
input property_meta_insert_input {
  author: String
  block_number: Int
  lockup: property_lockup_arr_rel_insert_input
  name: String
  property: String
  sender: String
  symbol: String
  total_supply: numeric
}

# aggregate max on columns
type property_meta_max_fields {
  author: String
  block_number: Int
  name: String
  property: String
  sender: String
  symbol: String
  total_supply: numeric
}

# order by max() on columns of table "property_meta"
input property_meta_max_order_by {
  author: order_by
  block_number: order_by
  name: order_by
  property: order_by
  sender: order_by
  symbol: order_by
  total_supply: order_by
}

# aggregate min on columns
type property_meta_min_fields {
  author: String
  block_number: Int
  name: String
  property: String
  sender: String
  symbol: String
  total_supply: numeric
}

# order by min() on columns of table "property_meta"
input property_meta_min_order_by {
  author: order_by
  block_number: order_by
  name: order_by
  property: order_by
  sender: order_by
  symbol: order_by
  total_supply: order_by
}

# response of any mutation on the table "property_meta"
type property_meta_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [property_meta!]!
}

# input type for inserting object relation for remote table "property_meta"
input property_meta_obj_rel_insert_input {
  data: property_meta_insert_input!
  on_conflict: property_meta_on_conflict
}

# on conflict condition type for table "property_meta"
input property_meta_on_conflict {
  constraint: property_meta_constraint!
  update_columns: [property_meta_update_column!]!
  where: property_meta_bool_exp
}

# ordering options when selecting data from "property_meta"
input property_meta_order_by {
  author: order_by
  block_number: order_by
  lockup_aggregate: property_lockup_aggregate_order_by
  name: order_by
  property: order_by
  sender: order_by
  symbol: order_by
  total_supply: order_by
}

# primary key columns input for table: "property_meta"
input property_meta_pk_columns_input {
  # property author address
  author: String!

  # property address
  property: String!
}

# select columns of table "property_meta"
enum property_meta_select_column {
  # column name
  author

  # column name
  block_number

  # column name
  name

  # column name
  property

  # column name
  sender

  # column name
  symbol

  # column name
  total_supply
}

# input type for updating data in table "property_meta"
input property_meta_set_input {
  author: String
  block_number: Int
  name: String
  property: String
  sender: String
  symbol: String
  total_supply: numeric
}

# aggregate stddev on columns
type property_meta_stddev_fields {
  block_number: Float
  total_supply: Float
}

# order by stddev() on columns of table "property_meta"
input property_meta_stddev_order_by {
  block_number: order_by
  total_supply: order_by
}

# aggregate stddev_pop on columns
type property_meta_stddev_pop_fields {
  block_number: Float
  total_supply: Float
}

# order by stddev_pop() on columns of table "property_meta"
input property_meta_stddev_pop_order_by {
  block_number: order_by
  total_supply: order_by
}

# aggregate stddev_samp on columns
type property_meta_stddev_samp_fields {
  block_number: Float
  total_supply: Float
}

# order by stddev_samp() on columns of table "property_meta"
input property_meta_stddev_samp_order_by {
  block_number: order_by
  total_supply: order_by
}

# aggregate sum on columns
type property_meta_sum_fields {
  block_number: Int
  total_supply: numeric
}

# order by sum() on columns of table "property_meta"
input property_meta_sum_order_by {
  block_number: order_by
  total_supply: order_by
}

# update columns of table "property_meta"
enum property_meta_update_column {
  # column name
  author

  # column name
  block_number

  # column name
  name

  # column name
  property

  # column name
  sender

  # column name
  symbol

  # column name
  total_supply
}

# aggregate var_pop on columns
type property_meta_var_pop_fields {
  block_number: Float
  total_supply: Float
}

# order by var_pop() on columns of table "property_meta"
input property_meta_var_pop_order_by {
  block_number: order_by
  total_supply: order_by
}

# aggregate var_samp on columns
type property_meta_var_samp_fields {
  block_number: Float
  total_supply: Float
}

# order by var_samp() on columns of table "property_meta"
input property_meta_var_samp_order_by {
  block_number: order_by
  total_supply: order_by
}

# aggregate variance on columns
type property_meta_variance_fields {
  block_number: Float
  total_supply: Float
}

# order by variance() on columns of table "property_meta"
input property_meta_variance_order_by {
  block_number: order_by
  total_supply: order_by
}

# query root
type query_root {
  # fetch data from the table: "account_lockup"
  account_lockup(
    # distinct select on columns
    distinct_on: [account_lockup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_lockup_order_by!]

    # filter the rows returned
    where: account_lockup_bool_exp
  ): [account_lockup!]!

  # fetch aggregated fields from the table: "account_lockup"
  account_lockup_aggregate(
    # distinct select on columns
    distinct_on: [account_lockup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_lockup_order_by!]

    # filter the rows returned
    where: account_lockup_bool_exp
  ): account_lockup_aggregate!

  # fetch data from the table: "account_lockup" using primary key columns
  account_lockup_by_pk(
    # account address
    account_address: String!

    # property address
    property_address: String!
  ): account_lockup

  # fetch data from the table: "account_lockup_sum_values"
  account_lockup_sum_values(
    # distinct select on columns
    distinct_on: [account_lockup_sum_values_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_lockup_sum_values_order_by!]

    # filter the rows returned
    where: account_lockup_sum_values_bool_exp
  ): [account_lockup_sum_values!]!

  # fetch aggregated fields from the table: "account_lockup_sum_values"
  account_lockup_sum_values_aggregate(
    # distinct select on columns
    distinct_on: [account_lockup_sum_values_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_lockup_sum_values_order_by!]

    # filter the rows returned
    where: account_lockup_sum_values_bool_exp
  ): account_lockup_sum_values_aggregate!

  # fetch data from the table: "dev_property_transfer"
  dev_property_transfer(
    # distinct select on columns
    distinct_on: [dev_property_transfer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [dev_property_transfer_order_by!]

    # filter the rows returned
    where: dev_property_transfer_bool_exp
  ): [dev_property_transfer!]!

  # fetch aggregated fields from the table: "dev_property_transfer"
  dev_property_transfer_aggregate(
    # distinct select on columns
    distinct_on: [dev_property_transfer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [dev_property_transfer_order_by!]

    # filter the rows returned
    where: dev_property_transfer_bool_exp
  ): dev_property_transfer_aggregate!

  # fetch data from the table: "dev_property_transfer" using primary key columns
  dev_property_transfer_by_pk(
    # event id
    event_id: String!
  ): dev_property_transfer

  # fetch data from the table: "lockup_lockedup"
  lockup_lockedup(
    # distinct select on columns
    distinct_on: [lockup_lockedup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lockup_lockedup_order_by!]

    # filter the rows returned
    where: lockup_lockedup_bool_exp
  ): [lockup_lockedup!]!

  # fetch aggregated fields from the table: "lockup_lockedup"
  lockup_lockedup_aggregate(
    # distinct select on columns
    distinct_on: [lockup_lockedup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lockup_lockedup_order_by!]

    # filter the rows returned
    where: lockup_lockedup_bool_exp
  ): lockup_lockedup_aggregate!

  # fetch data from the table: "lockup_lockedup" using primary key columns
  lockup_lockedup_by_pk(
    # event id
    event_id: String!
  ): lockup_lockedup

  # fetch data from the table: "market_factory_create"
  market_factory_create(
    # distinct select on columns
    distinct_on: [market_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [market_factory_create_order_by!]

    # filter the rows returned
    where: market_factory_create_bool_exp
  ): [market_factory_create!]!

  # fetch aggregated fields from the table: "market_factory_create"
  market_factory_create_aggregate(
    # distinct select on columns
    distinct_on: [market_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [market_factory_create_order_by!]

    # filter the rows returned
    where: market_factory_create_bool_exp
  ): market_factory_create_aggregate!

  # fetch data from the table: "market_factory_create" using primary key columns
  market_factory_create_by_pk(
    # event id
    event_id: String!
  ): market_factory_create

  # fetch data from the table: "metrics_factory_create"
  metrics_factory_create(
    # distinct select on columns
    distinct_on: [metrics_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [metrics_factory_create_order_by!]

    # filter the rows returned
    where: metrics_factory_create_bool_exp
  ): [metrics_factory_create!]!

  # fetch aggregated fields from the table: "metrics_factory_create"
  metrics_factory_create_aggregate(
    # distinct select on columns
    distinct_on: [metrics_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [metrics_factory_create_order_by!]

    # filter the rows returned
    where: metrics_factory_create_bool_exp
  ): metrics_factory_create_aggregate!

  # fetch data from the table: "metrics_factory_create" using primary key columns
  metrics_factory_create_by_pk(
    # event id
    event_id: String!
  ): metrics_factory_create

  # fetch data from the table: "metrics_factory_destroy"
  metrics_factory_destroy(
    # distinct select on columns
    distinct_on: [metrics_factory_destroy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [metrics_factory_destroy_order_by!]

    # filter the rows returned
    where: metrics_factory_destroy_bool_exp
  ): [metrics_factory_destroy!]!

  # fetch aggregated fields from the table: "metrics_factory_destroy"
  metrics_factory_destroy_aggregate(
    # distinct select on columns
    distinct_on: [metrics_factory_destroy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [metrics_factory_destroy_order_by!]

    # filter the rows returned
    where: metrics_factory_destroy_bool_exp
  ): metrics_factory_destroy_aggregate!

  # fetch data from the table: "metrics_factory_destroy" using primary key columns
  metrics_factory_destroy_by_pk(
    # event id
    event_id: String!
  ): metrics_factory_destroy

  # fetch data from the table: "policy_factory_create"
  policy_factory_create(
    # distinct select on columns
    distinct_on: [policy_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [policy_factory_create_order_by!]

    # filter the rows returned
    where: policy_factory_create_bool_exp
  ): [policy_factory_create!]!

  # fetch aggregated fields from the table: "policy_factory_create"
  policy_factory_create_aggregate(
    # distinct select on columns
    distinct_on: [policy_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [policy_factory_create_order_by!]

    # filter the rows returned
    where: policy_factory_create_bool_exp
  ): policy_factory_create_aggregate!

  # fetch data from the table: "policy_factory_create" using primary key columns
  policy_factory_create_by_pk(
    # event id
    event_id: String!
  ): policy_factory_create

  # fetch data from the table: "property_authentication"
  property_authentication(
    # distinct select on columns
    distinct_on: [property_authentication_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_authentication_order_by!]

    # filter the rows returned
    where: property_authentication_bool_exp
  ): [property_authentication!]!

  # fetch aggregated fields from the table: "property_authentication"
  property_authentication_aggregate(
    # distinct select on columns
    distinct_on: [property_authentication_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_authentication_order_by!]

    # filter the rows returned
    where: property_authentication_bool_exp
  ): property_authentication_aggregate!

  # fetch data from the table: "property_authentication" using primary key columns
  property_authentication_by_pk(
    # the metrics address for authentication
    metrics: String!

    # property address
    property: String!
  ): property_authentication

  # fetch data from the table: "property_authentication_deleted"
  property_authentication_deleted(
    # distinct select on columns
    distinct_on: [property_authentication_deleted_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_authentication_deleted_order_by!]

    # filter the rows returned
    where: property_authentication_deleted_bool_exp
  ): [property_authentication_deleted!]!

  # fetch aggregated fields from the table: "property_authentication_deleted"
  property_authentication_deleted_aggregate(
    # distinct select on columns
    distinct_on: [property_authentication_deleted_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_authentication_deleted_order_by!]

    # filter the rows returned
    where: property_authentication_deleted_bool_exp
  ): property_authentication_deleted_aggregate!

  # fetch data from the table: "property_authentication_deleted" using primary key columns
  property_authentication_deleted_by_pk(
    # disabled metrics address for authentication
    metrics: String!

    # property address
    property: String!
  ): property_authentication_deleted

  # fetch data from the table: "property_balance"
  property_balance(
    # distinct select on columns
    distinct_on: [property_balance_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_balance_order_by!]

    # filter the rows returned
    where: property_balance_bool_exp
  ): [property_balance!]!

  # fetch aggregated fields from the table: "property_balance"
  property_balance_aggregate(
    # distinct select on columns
    distinct_on: [property_balance_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_balance_order_by!]

    # filter the rows returned
    where: property_balance_bool_exp
  ): property_balance_aggregate!

  # fetch data from the table: "property_balance" using primary key columns
  property_balance_by_pk(
    # account_address
    account_address: String!

    # property address
    property_address: String!
  ): property_balance

  # fetch data from the table: "property_factory_create"
  property_factory_create(
    # distinct select on columns
    distinct_on: [property_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_factory_create_order_by!]

    # filter the rows returned
    where: property_factory_create_bool_exp
  ): [property_factory_create!]!

  # fetch aggregated fields from the table: "property_factory_create"
  property_factory_create_aggregate(
    # distinct select on columns
    distinct_on: [property_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_factory_create_order_by!]

    # filter the rows returned
    where: property_factory_create_bool_exp
  ): property_factory_create_aggregate!

  # fetch data from the table: "property_factory_create" using primary key columns
  property_factory_create_by_pk(
    # event id
    event_id: String!
  ): property_factory_create

  # fetch data from the table: "property_lockup"
  property_lockup(
    # distinct select on columns
    distinct_on: [property_lockup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_lockup_order_by!]

    # filter the rows returned
    where: property_lockup_bool_exp
  ): [property_lockup!]!

  # fetch aggregated fields from the table: "property_lockup"
  property_lockup_aggregate(
    # distinct select on columns
    distinct_on: [property_lockup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_lockup_order_by!]

    # filter the rows returned
    where: property_lockup_bool_exp
  ): property_lockup_aggregate!

  # fetch data from the table: "property_lockup" using primary key columns
  property_lockup_by_pk(
    # account address
    account_address: String!

    # property address
    property_address: String!
  ): property_lockup

  # fetch data from the table: "property_lockup_sum_values"
  property_lockup_sum_values(
    # distinct select on columns
    distinct_on: [property_lockup_sum_values_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_lockup_sum_values_order_by!]

    # filter the rows returned
    where: property_lockup_sum_values_bool_exp
  ): [property_lockup_sum_values!]!

  # fetch aggregated fields from the table: "property_lockup_sum_values"
  property_lockup_sum_values_aggregate(
    # distinct select on columns
    distinct_on: [property_lockup_sum_values_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_lockup_sum_values_order_by!]

    # filter the rows returned
    where: property_lockup_sum_values_bool_exp
  ): property_lockup_sum_values_aggregate!

  # fetch data from the table: "property_meta"
  property_meta(
    # distinct select on columns
    distinct_on: [property_meta_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_meta_order_by!]

    # filter the rows returned
    where: property_meta_bool_exp
  ): [property_meta!]!

  # fetch aggregated fields from the table: "property_meta"
  property_meta_aggregate(
    # distinct select on columns
    distinct_on: [property_meta_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_meta_order_by!]

    # filter the rows returned
    where: property_meta_bool_exp
  ): property_meta_aggregate!

  # fetch data from the table: "property_meta" using primary key columns
  property_meta_by_pk(
    # property author address
    author: String!

    # property address
    property: String!
  ): property_meta

  # fetch data from the table: "withdraw_property_transfer"
  withdraw_property_transfer(
    # distinct select on columns
    distinct_on: [withdraw_property_transfer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [withdraw_property_transfer_order_by!]

    # filter the rows returned
    where: withdraw_property_transfer_bool_exp
  ): [withdraw_property_transfer!]!

  # fetch aggregated fields from the table: "withdraw_property_transfer"
  withdraw_property_transfer_aggregate(
    # distinct select on columns
    distinct_on: [withdraw_property_transfer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [withdraw_property_transfer_order_by!]

    # filter the rows returned
    where: withdraw_property_transfer_bool_exp
  ): withdraw_property_transfer_aggregate!

  # fetch data from the table: "withdraw_property_transfer" using primary key columns
  withdraw_property_transfer_by_pk(
    # event id
    event_id: String!
  ): withdraw_property_transfer
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "account_lockup"
  account_lockup(
    # distinct select on columns
    distinct_on: [account_lockup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_lockup_order_by!]

    # filter the rows returned
    where: account_lockup_bool_exp
  ): [account_lockup!]!

  # fetch aggregated fields from the table: "account_lockup"
  account_lockup_aggregate(
    # distinct select on columns
    distinct_on: [account_lockup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_lockup_order_by!]

    # filter the rows returned
    where: account_lockup_bool_exp
  ): account_lockup_aggregate!

  # fetch data from the table: "account_lockup" using primary key columns
  account_lockup_by_pk(
    # account address
    account_address: String!

    # property address
    property_address: String!
  ): account_lockup

  # fetch data from the table: "account_lockup_sum_values"
  account_lockup_sum_values(
    # distinct select on columns
    distinct_on: [account_lockup_sum_values_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_lockup_sum_values_order_by!]

    # filter the rows returned
    where: account_lockup_sum_values_bool_exp
  ): [account_lockup_sum_values!]!

  # fetch aggregated fields from the table: "account_lockup_sum_values"
  account_lockup_sum_values_aggregate(
    # distinct select on columns
    distinct_on: [account_lockup_sum_values_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_lockup_sum_values_order_by!]

    # filter the rows returned
    where: account_lockup_sum_values_bool_exp
  ): account_lockup_sum_values_aggregate!

  # fetch data from the table: "dev_property_transfer"
  dev_property_transfer(
    # distinct select on columns
    distinct_on: [dev_property_transfer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [dev_property_transfer_order_by!]

    # filter the rows returned
    where: dev_property_transfer_bool_exp
  ): [dev_property_transfer!]!

  # fetch aggregated fields from the table: "dev_property_transfer"
  dev_property_transfer_aggregate(
    # distinct select on columns
    distinct_on: [dev_property_transfer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [dev_property_transfer_order_by!]

    # filter the rows returned
    where: dev_property_transfer_bool_exp
  ): dev_property_transfer_aggregate!

  # fetch data from the table: "dev_property_transfer" using primary key columns
  dev_property_transfer_by_pk(
    # event id
    event_id: String!
  ): dev_property_transfer

  # fetch data from the table: "lockup_lockedup"
  lockup_lockedup(
    # distinct select on columns
    distinct_on: [lockup_lockedup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lockup_lockedup_order_by!]

    # filter the rows returned
    where: lockup_lockedup_bool_exp
  ): [lockup_lockedup!]!

  # fetch aggregated fields from the table: "lockup_lockedup"
  lockup_lockedup_aggregate(
    # distinct select on columns
    distinct_on: [lockup_lockedup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [lockup_lockedup_order_by!]

    # filter the rows returned
    where: lockup_lockedup_bool_exp
  ): lockup_lockedup_aggregate!

  # fetch data from the table: "lockup_lockedup" using primary key columns
  lockup_lockedup_by_pk(
    # event id
    event_id: String!
  ): lockup_lockedup

  # fetch data from the table: "market_factory_create"
  market_factory_create(
    # distinct select on columns
    distinct_on: [market_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [market_factory_create_order_by!]

    # filter the rows returned
    where: market_factory_create_bool_exp
  ): [market_factory_create!]!

  # fetch aggregated fields from the table: "market_factory_create"
  market_factory_create_aggregate(
    # distinct select on columns
    distinct_on: [market_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [market_factory_create_order_by!]

    # filter the rows returned
    where: market_factory_create_bool_exp
  ): market_factory_create_aggregate!

  # fetch data from the table: "market_factory_create" using primary key columns
  market_factory_create_by_pk(
    # event id
    event_id: String!
  ): market_factory_create

  # fetch data from the table: "metrics_factory_create"
  metrics_factory_create(
    # distinct select on columns
    distinct_on: [metrics_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [metrics_factory_create_order_by!]

    # filter the rows returned
    where: metrics_factory_create_bool_exp
  ): [metrics_factory_create!]!

  # fetch aggregated fields from the table: "metrics_factory_create"
  metrics_factory_create_aggregate(
    # distinct select on columns
    distinct_on: [metrics_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [metrics_factory_create_order_by!]

    # filter the rows returned
    where: metrics_factory_create_bool_exp
  ): metrics_factory_create_aggregate!

  # fetch data from the table: "metrics_factory_create" using primary key columns
  metrics_factory_create_by_pk(
    # event id
    event_id: String!
  ): metrics_factory_create

  # fetch data from the table: "metrics_factory_destroy"
  metrics_factory_destroy(
    # distinct select on columns
    distinct_on: [metrics_factory_destroy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [metrics_factory_destroy_order_by!]

    # filter the rows returned
    where: metrics_factory_destroy_bool_exp
  ): [metrics_factory_destroy!]!

  # fetch aggregated fields from the table: "metrics_factory_destroy"
  metrics_factory_destroy_aggregate(
    # distinct select on columns
    distinct_on: [metrics_factory_destroy_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [metrics_factory_destroy_order_by!]

    # filter the rows returned
    where: metrics_factory_destroy_bool_exp
  ): metrics_factory_destroy_aggregate!

  # fetch data from the table: "metrics_factory_destroy" using primary key columns
  metrics_factory_destroy_by_pk(
    # event id
    event_id: String!
  ): metrics_factory_destroy

  # fetch data from the table: "policy_factory_create"
  policy_factory_create(
    # distinct select on columns
    distinct_on: [policy_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [policy_factory_create_order_by!]

    # filter the rows returned
    where: policy_factory_create_bool_exp
  ): [policy_factory_create!]!

  # fetch aggregated fields from the table: "policy_factory_create"
  policy_factory_create_aggregate(
    # distinct select on columns
    distinct_on: [policy_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [policy_factory_create_order_by!]

    # filter the rows returned
    where: policy_factory_create_bool_exp
  ): policy_factory_create_aggregate!

  # fetch data from the table: "policy_factory_create" using primary key columns
  policy_factory_create_by_pk(
    # event id
    event_id: String!
  ): policy_factory_create

  # fetch data from the table: "property_authentication"
  property_authentication(
    # distinct select on columns
    distinct_on: [property_authentication_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_authentication_order_by!]

    # filter the rows returned
    where: property_authentication_bool_exp
  ): [property_authentication!]!

  # fetch aggregated fields from the table: "property_authentication"
  property_authentication_aggregate(
    # distinct select on columns
    distinct_on: [property_authentication_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_authentication_order_by!]

    # filter the rows returned
    where: property_authentication_bool_exp
  ): property_authentication_aggregate!

  # fetch data from the table: "property_authentication" using primary key columns
  property_authentication_by_pk(
    # the metrics address for authentication
    metrics: String!

    # property address
    property: String!
  ): property_authentication

  # fetch data from the table: "property_authentication_deleted"
  property_authentication_deleted(
    # distinct select on columns
    distinct_on: [property_authentication_deleted_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_authentication_deleted_order_by!]

    # filter the rows returned
    where: property_authentication_deleted_bool_exp
  ): [property_authentication_deleted!]!

  # fetch aggregated fields from the table: "property_authentication_deleted"
  property_authentication_deleted_aggregate(
    # distinct select on columns
    distinct_on: [property_authentication_deleted_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_authentication_deleted_order_by!]

    # filter the rows returned
    where: property_authentication_deleted_bool_exp
  ): property_authentication_deleted_aggregate!

  # fetch data from the table: "property_authentication_deleted" using primary key columns
  property_authentication_deleted_by_pk(
    # disabled metrics address for authentication
    metrics: String!

    # property address
    property: String!
  ): property_authentication_deleted

  # fetch data from the table: "property_balance"
  property_balance(
    # distinct select on columns
    distinct_on: [property_balance_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_balance_order_by!]

    # filter the rows returned
    where: property_balance_bool_exp
  ): [property_balance!]!

  # fetch aggregated fields from the table: "property_balance"
  property_balance_aggregate(
    # distinct select on columns
    distinct_on: [property_balance_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_balance_order_by!]

    # filter the rows returned
    where: property_balance_bool_exp
  ): property_balance_aggregate!

  # fetch data from the table: "property_balance" using primary key columns
  property_balance_by_pk(
    # account_address
    account_address: String!

    # property address
    property_address: String!
  ): property_balance

  # fetch data from the table: "property_factory_create"
  property_factory_create(
    # distinct select on columns
    distinct_on: [property_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_factory_create_order_by!]

    # filter the rows returned
    where: property_factory_create_bool_exp
  ): [property_factory_create!]!

  # fetch aggregated fields from the table: "property_factory_create"
  property_factory_create_aggregate(
    # distinct select on columns
    distinct_on: [property_factory_create_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_factory_create_order_by!]

    # filter the rows returned
    where: property_factory_create_bool_exp
  ): property_factory_create_aggregate!

  # fetch data from the table: "property_factory_create" using primary key columns
  property_factory_create_by_pk(
    # event id
    event_id: String!
  ): property_factory_create

  # fetch data from the table: "property_lockup"
  property_lockup(
    # distinct select on columns
    distinct_on: [property_lockup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_lockup_order_by!]

    # filter the rows returned
    where: property_lockup_bool_exp
  ): [property_lockup!]!

  # fetch aggregated fields from the table: "property_lockup"
  property_lockup_aggregate(
    # distinct select on columns
    distinct_on: [property_lockup_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_lockup_order_by!]

    # filter the rows returned
    where: property_lockup_bool_exp
  ): property_lockup_aggregate!

  # fetch data from the table: "property_lockup" using primary key columns
  property_lockup_by_pk(
    # account address
    account_address: String!

    # property address
    property_address: String!
  ): property_lockup

  # fetch data from the table: "property_lockup_sum_values"
  property_lockup_sum_values(
    # distinct select on columns
    distinct_on: [property_lockup_sum_values_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_lockup_sum_values_order_by!]

    # filter the rows returned
    where: property_lockup_sum_values_bool_exp
  ): [property_lockup_sum_values!]!

  # fetch aggregated fields from the table: "property_lockup_sum_values"
  property_lockup_sum_values_aggregate(
    # distinct select on columns
    distinct_on: [property_lockup_sum_values_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_lockup_sum_values_order_by!]

    # filter the rows returned
    where: property_lockup_sum_values_bool_exp
  ): property_lockup_sum_values_aggregate!

  # fetch data from the table: "property_meta"
  property_meta(
    # distinct select on columns
    distinct_on: [property_meta_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_meta_order_by!]

    # filter the rows returned
    where: property_meta_bool_exp
  ): [property_meta!]!

  # fetch aggregated fields from the table: "property_meta"
  property_meta_aggregate(
    # distinct select on columns
    distinct_on: [property_meta_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [property_meta_order_by!]

    # filter the rows returned
    where: property_meta_bool_exp
  ): property_meta_aggregate!

  # fetch data from the table: "property_meta" using primary key columns
  property_meta_by_pk(
    # property author address
    author: String!

    # property address
    property: String!
  ): property_meta

  # fetch data from the table: "withdraw_property_transfer"
  withdraw_property_transfer(
    # distinct select on columns
    distinct_on: [withdraw_property_transfer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [withdraw_property_transfer_order_by!]

    # filter the rows returned
    where: withdraw_property_transfer_bool_exp
  ): [withdraw_property_transfer!]!

  # fetch aggregated fields from the table: "withdraw_property_transfer"
  withdraw_property_transfer_aggregate(
    # distinct select on columns
    distinct_on: [withdraw_property_transfer_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [withdraw_property_transfer_order_by!]

    # filter the rows returned
    where: withdraw_property_transfer_bool_exp
  ): withdraw_property_transfer_aggregate!

  # fetch data from the table: "withdraw_property_transfer" using primary key columns
  withdraw_property_transfer_by_pk(
    # event id
    event_id: String!
  ): withdraw_property_transfer
}

# property transfer information
#
#
# columns and relationships of "withdraw_property_transfer"
#
type withdraw_property_transfer {
  # event block number
  block_number: Int!

  # event id
  event_id: String!

  # from address
  from_address: String!

  # event log index
  log_index: Int!

  # property address
  property_address: String!

  # event raw data
  raw_data: String!

  # to address
  to_address: String!

  # event transaction index
  transaction_index: Int!
}

# aggregated selection of "withdraw_property_transfer"
type withdraw_property_transfer_aggregate {
  aggregate: withdraw_property_transfer_aggregate_fields
  nodes: [withdraw_property_transfer!]!
}

# aggregate fields of "withdraw_property_transfer"
type withdraw_property_transfer_aggregate_fields {
  avg: withdraw_property_transfer_avg_fields
  count(columns: [withdraw_property_transfer_select_column!], distinct: Boolean): Int
  max: withdraw_property_transfer_max_fields
  min: withdraw_property_transfer_min_fields
  stddev: withdraw_property_transfer_stddev_fields
  stddev_pop: withdraw_property_transfer_stddev_pop_fields
  stddev_samp: withdraw_property_transfer_stddev_samp_fields
  sum: withdraw_property_transfer_sum_fields
  var_pop: withdraw_property_transfer_var_pop_fields
  var_samp: withdraw_property_transfer_var_samp_fields
  variance: withdraw_property_transfer_variance_fields
}

# order by aggregate values of table "withdraw_property_transfer"
input withdraw_property_transfer_aggregate_order_by {
  avg: withdraw_property_transfer_avg_order_by
  count: order_by
  max: withdraw_property_transfer_max_order_by
  min: withdraw_property_transfer_min_order_by
  stddev: withdraw_property_transfer_stddev_order_by
  stddev_pop: withdraw_property_transfer_stddev_pop_order_by
  stddev_samp: withdraw_property_transfer_stddev_samp_order_by
  sum: withdraw_property_transfer_sum_order_by
  var_pop: withdraw_property_transfer_var_pop_order_by
  var_samp: withdraw_property_transfer_var_samp_order_by
  variance: withdraw_property_transfer_variance_order_by
}

# input type for inserting array relation for remote table "withdraw_property_transfer"
input withdraw_property_transfer_arr_rel_insert_input {
  data: [withdraw_property_transfer_insert_input!]!
  on_conflict: withdraw_property_transfer_on_conflict
}

# aggregate avg on columns
type withdraw_property_transfer_avg_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by avg() on columns of table "withdraw_property_transfer"
input withdraw_property_transfer_avg_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# Boolean expression to filter rows from the table "withdraw_property_transfer". All fields are combined with a logical 'AND'.
input withdraw_property_transfer_bool_exp {
  _and: [withdraw_property_transfer_bool_exp]
  _not: withdraw_property_transfer_bool_exp
  _or: [withdraw_property_transfer_bool_exp]
  block_number: Int_comparison_exp
  event_id: String_comparison_exp
  from_address: String_comparison_exp
  log_index: Int_comparison_exp
  property_address: String_comparison_exp
  raw_data: String_comparison_exp
  to_address: String_comparison_exp
  transaction_index: Int_comparison_exp
}

# unique or primary key constraints on table "withdraw_property_transfer"
enum withdraw_property_transfer_constraint {
  # unique or primary key constraint
  withdraw_property_transfer_pkey
}

# input type for incrementing integer column in table "withdraw_property_transfer"
input withdraw_property_transfer_inc_input {
  block_number: Int
  log_index: Int
  transaction_index: Int
}

# input type for inserting data into table "withdraw_property_transfer"
input withdraw_property_transfer_insert_input {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  property_address: String
  raw_data: String
  to_address: String
  transaction_index: Int
}

# aggregate max on columns
type withdraw_property_transfer_max_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  property_address: String
  raw_data: String
  to_address: String
  transaction_index: Int
}

# order by max() on columns of table "withdraw_property_transfer"
input withdraw_property_transfer_max_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  property_address: order_by
  raw_data: order_by
  to_address: order_by
  transaction_index: order_by
}

# aggregate min on columns
type withdraw_property_transfer_min_fields {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  property_address: String
  raw_data: String
  to_address: String
  transaction_index: Int
}

# order by min() on columns of table "withdraw_property_transfer"
input withdraw_property_transfer_min_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  property_address: order_by
  raw_data: order_by
  to_address: order_by
  transaction_index: order_by
}

# response of any mutation on the table "withdraw_property_transfer"
type withdraw_property_transfer_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [withdraw_property_transfer!]!
}

# input type for inserting object relation for remote table "withdraw_property_transfer"
input withdraw_property_transfer_obj_rel_insert_input {
  data: withdraw_property_transfer_insert_input!
  on_conflict: withdraw_property_transfer_on_conflict
}

# on conflict condition type for table "withdraw_property_transfer"
input withdraw_property_transfer_on_conflict {
  constraint: withdraw_property_transfer_constraint!
  update_columns: [withdraw_property_transfer_update_column!]!
  where: withdraw_property_transfer_bool_exp
}

# ordering options when selecting data from "withdraw_property_transfer"
input withdraw_property_transfer_order_by {
  block_number: order_by
  event_id: order_by
  from_address: order_by
  log_index: order_by
  property_address: order_by
  raw_data: order_by
  to_address: order_by
  transaction_index: order_by
}

# primary key columns input for table: "withdraw_property_transfer"
input withdraw_property_transfer_pk_columns_input {
  # event id
  event_id: String!
}

# select columns of table "withdraw_property_transfer"
enum withdraw_property_transfer_select_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  log_index

  # column name
  property_address

  # column name
  raw_data

  # column name
  to_address

  # column name
  transaction_index
}

# input type for updating data in table "withdraw_property_transfer"
input withdraw_property_transfer_set_input {
  block_number: Int
  event_id: String
  from_address: String
  log_index: Int
  property_address: String
  raw_data: String
  to_address: String
  transaction_index: Int
}

# aggregate stddev on columns
type withdraw_property_transfer_stddev_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev() on columns of table "withdraw_property_transfer"
input withdraw_property_transfer_stddev_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate stddev_pop on columns
type withdraw_property_transfer_stddev_pop_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev_pop() on columns of table "withdraw_property_transfer"
input withdraw_property_transfer_stddev_pop_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate stddev_samp on columns
type withdraw_property_transfer_stddev_samp_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by stddev_samp() on columns of table "withdraw_property_transfer"
input withdraw_property_transfer_stddev_samp_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate sum on columns
type withdraw_property_transfer_sum_fields {
  block_number: Int
  log_index: Int
  transaction_index: Int
}

# order by sum() on columns of table "withdraw_property_transfer"
input withdraw_property_transfer_sum_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# update columns of table "withdraw_property_transfer"
enum withdraw_property_transfer_update_column {
  # column name
  block_number

  # column name
  event_id

  # column name
  from_address

  # column name
  log_index

  # column name
  property_address

  # column name
  raw_data

  # column name
  to_address

  # column name
  transaction_index
}

# aggregate var_pop on columns
type withdraw_property_transfer_var_pop_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by var_pop() on columns of table "withdraw_property_transfer"
input withdraw_property_transfer_var_pop_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate var_samp on columns
type withdraw_property_transfer_var_samp_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by var_samp() on columns of table "withdraw_property_transfer"
input withdraw_property_transfer_var_samp_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}

# aggregate variance on columns
type withdraw_property_transfer_variance_fields {
  block_number: Float
  log_index: Float
  transaction_index: Float
}

# order by variance() on columns of table "withdraw_property_transfer"
input withdraw_property_transfer_variance_order_by {
  block_number: order_by
  log_index: order_by
  transaction_index: order_by
}
